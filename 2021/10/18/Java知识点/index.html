<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hazykam.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>


<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
  <meta name="description" content="面向对象什么是面向对象 对比面向过程，是两种不同的处理问题时的角度 面向过程更注重实现的每一个步骤及顺序，面向对象更注重实现过程中有哪些参与者（对象）、以及每个对象需要做什么">
<meta property="og:type" content="article">
<meta property="og:title" content="Java知识点">
<meta property="og:url" content="https://hazykam.github.io/2021/10/18/Java%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="ANSWER-42">
<meta property="og:description" content="面向对象什么是面向对象 对比面向过程，是两种不同的处理问题时的角度 面向过程更注重实现的每一个步骤及顺序，面向对象更注重实现过程中有哪些参与者（对象）、以及每个对象需要做什么">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-18T09:08:17.000Z">
<meta property="article:modified_time" content="2021-10-18T10:31:25.347Z">
<meta property="article:author" content="胧">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hazykam.github.io/2021/10/18/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java知识点 | ANSWER-42</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <!-- live2d的依赖css和js，将其注释可以关闭live2d -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
  <script src="/live2d-widget/autoload.js"></script>
<link rel="alternate" href="/atom.xml" title="ANSWER-42" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ANSWER-42</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">但愿长醉不复醒</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">9</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hazykam.github.io/2021/10/18/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://portrait.gitee.com/uploads/avatars/user/2852/8558826_hazykam_1610350815.png">
      <meta itemprop="name" content="胧">
      <meta itemprop="description" content="echo 'Set free'">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ANSWER-42">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-18 17:08:17 / 修改时间：18:31:25" itemprop="dateCreated datePublished" datetime="2021-10-18T17:08:17+08:00">2021-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>什么是面向对象</p>
<p>对比面向过程，是两种不同的处理问题时的角度</p>
<p>面向过程更注重实现的每一个步骤及顺序，面向对象更注重实现过程中有哪些参与者（对象）、以及每个对象需要做什么</p>
<span id="more"></span>



<p>比如：人用洗衣机洗衣服</p>
<p>面向过程会将任务拆解成一系列的步骤（函数）：打开洗衣机 -&gt; 放入衣物 -&gt; 倒洗衣液 -&gt; 清洗 -&gt; 烘干</p>
<p>面向对象会拆出人和洗衣机两个对象：</p>
<p>人做的事：打开洗衣机、放入衣物、倒洗衣液</p>
<p>洗衣机做的事：清洗、烘干</p>
<p>面向过程更加直接高效，而面向对象更易于复用、扩展和维护</p>
<h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><p><strong>封装</strong>：封装的意义在于明确标识出允许外部使用的成员函数和属性，内部细节对外部调用者透明，调用者无需关心内部实现</p>
<p><strong>继承</strong>：继承基类的方法，并作出自己的改变和扩展，父子类中共性的方法或属性可以直接调用父类中的，而不需要再额外定义，只需在子类扩展一些额外的功能</p>
<p><strong>多态</strong>：多态基于继承特性，基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同</p>
<p>继承父类 -&gt; 重写父类方法 -&gt; 父类引用指向子类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>

<p>使用多态特性时，无法调用子类特有的方法</p>
<hr>
<p>stack：栈</p>
<p>heap：堆</p>
<h3 id="JDK、JRE和JVM的关系"><a href="#JDK、JRE和JVM的关系" class="headerlink" title="JDK、JRE和JVM的关系"></a>JDK、JRE和JVM的关系</h3><p>JDK（Java开发工具包）中包含了JRE（Java运行环境），JRE中包含了JVM（Java虚拟机）。</p>
<p>.java文件通过JDK中的javac编译后生成.class文件，class文件可以在不同平台的JVM上来调用JRE的lib类库来进行解释运行。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final修饰类，表示类不可变，不可继承，比如String具有不可变性</p>
<p>final修饰方法，表示该方法不可重写，比如模板方法，可以固定我们的算法</p>
<p>final修饰变量，这个变量就会变为常量</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>修饰的是基本数据类型，这个值本身不能修改；</p>
</li>
<li><p><span id="final-ref">==<strong>修饰的是引用类型，引用的指向不能够改变，但是引用类型中的属性可以改变</strong>==</span></p>
</li>
</ul>
<p>引用类型会在栈中拥有一个引用，这个引用指向了堆中的一块内存，也就是对象的信息</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Student student = <span class="keyword">new</span> Student(<span class="number">18</span>, <span class="string">&quot;Joker&quot;</span>);</span><br><span class="line">student.setName(<span class="string">&quot;Panther&quot;</span>);    <span class="comment">// 注意，这种是可以的</span></span><br></pre></td></tr></table></figure>

<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>抽象类中可以存在普通成员函数，接口中只能存在public abstract方法，这是默认强制的。</li>
<li>抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型的，这是默认强制的。</li>
<li>抽象类只能被继承一个，接口可以被实现多个。</li>
</ul>
<p>接口的设计目的，是对类的行为进行约束，接口要求实现类必须实现接口中所定义的抽象方法，是一种强制要求不同的类具有相同行为的机制，它约束了行为的有无，但不对具体实现进行限制。</p>
<p>抽象类的设计目的，是代码复用，当不同的类具有相同的行为，且部分行为的实现方式一致时，可以让这些类都继承一个抽象类，实现代码复用。而存在差异化的行为也就是抽象的方法，留给各个子类自己实现，抽象类因为存在抽象方法，所以不允许被实例化。</p>
<p>抽象类是对类的本质进行抽象，表达的是<code>is a</code>的关系，比如：<code>Benz is a Car</code>（奔驰是一部车），抽象类包含并实现了子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</p>
<p>接口是对行为的抽象，表达的是<code>like a</code>的关系，比如：<code>Bird like a Aircraft</code>（鸟像飞行器一样可以飞），实现类的本质没有变，但接口约束了一个类会有哪些行为，至于实现类主题是谁、如何实现，接口并不关心。</p>
<hr>
<h3 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h3><p>==在比较基本数据类型时，比较的是值；在比较引用类型时，比较的是引用指向的值，也就是地址；</p>
<p>equals只有引用类型可以调用，默认比较的也是地址，因为这个方法定义在Object上，默认的实现就是比较地址；</p>
<p>自定义的类，如果需要比较的是值而非地址，需要像String一样重写equals方法；</p>
<p>equals本质上就是==，只不过引用类型可以对其进行重写，将其变为值比较。</p>
<hr>
<h3 id="equals和hashCode的关系"><a href="#equals和hashCode的关系" class="headerlink" title="equals和hashCode的关系"></a>equals和hashCode的关系</h3><p>hashCode顾名思义是一个“<strong>散列值码</strong>”，散列值<strong>不具有唯一性</strong>，但<strong>具有离散性</strong>，其意义在于<strong>HashMap</strong>之类的集合<strong>可以通过hashCode快速比较对象</strong>，从而<strong>增加查询效率</strong>；</p>
<p>两个对象在使用equals方法进行比较时，hashCode必须相等，但<strong>hashCode相等并不代表两个对象一定相等</strong>；</p>
<p>如果没有重写hashCode方法，则使用Object默认的hashCode，<strong>默认的hashCode无法保证相同的两个对象hashCode也相等</strong>；</p>
<p><strong>一般情况下都建议重写hashCode方法</strong>，原因如下：</p>
<ul>
<li>如果想把对象放入Set中或者作为Map的key时，重写hashCode可以保证equals判断的准确性，确保元素或key的唯一。</li>
<li>在集合中比较两个对象是否相等时，如果两个对象的hashCode不相等，一般情况下就可以直接认为这两个对象不相等，如果hashCode相等，才会调用重写的equals方法进行值比较从而判断是否相等，可以提高比较的效率。</li>
</ul>
<p><strong>必须重写hashCode的情况</strong>：</p>
<p>如果想把对象存入例如HashSet、HashMap之类的以hashCode为核心的数据结构中，必须确保唯一性和查询效率，在重写equals的同时也必须重写hashCode，若不重写hashCode可能导致HashSet、HashMap不能正常的运作。</p>
<hr>
<h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><p>Effective Java中第15条<code>使可变性最小化</code>中对<code>不可变类</code>的解释：</p>
<p>不可变类是指实例不能被修改的类。每个实例中包含的所有信息都必须在创建实例时提供，并且在对象的整个生命周期内固定不变。</p>
<p>为了使类不可变，要遵循下面五条规则：</p>
<blockquote>
<ol>
<li><strong>不要提供任何会修改对象状态的方法。</strong></li>
<li><strong>保证类不会被扩展。</strong>一般的做法时让这个类被final所修饰，防止被子类继承，破坏该类的不可变行为。</li>
<li><strong>使所有的field都是final的。</strong></li>
<li><strong>使所有的field都为private。</strong>防止外界获得访问被field引用的可变对象的权限，并防止外界直接修改这些对象。</li>
<li><strong>确保对于任何可变性组件的互斥访问。</strong>如果类具有指向可变对象的field，则必须确保该类无法被外界获得指向这些对象的引用。</li>
</ol>
</blockquote>
<p>在Java类库中包含许多不可变类，例如：String、基本类型的包装类、BigInteger、BigDecimal等等。</p>
<p>综上所述，不可变类具有一些具有一些显著的通用特征：</p>
<ul>
<li>类本身是final修饰的</li>
<li>所有的field几乎都是private且final的</li>
<li>不会对外暴露可以修改实例属性的方法</li>
</ul>
<hr>
<h3 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h3><p>String是引用类型，String类型是不可变的，给一个已经有值的String对象进行二次赋值时，不会再原本的内存地址上修改数据，而是<strong>在堆中重新生成一个对象，将栈中的引用指向更改为新对象的地址</strong>。</p>
<h4 id="String源码实现"><a href="#String源码实现" class="headerlink" title="String源码实现"></a>String源码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">     * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../platform/serialization/spec/output.html&quot;&gt;</span></span><br><span class="line"><span class="comment">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看源码，String类本身是被final修饰的，满足了不可变类中，保证类不会被扩展的原则。</p>
<p>分析String中的几个field，其中最主要的是<code>value</code>，存储了String实例的值，由于使用了private final修饰，正常情况下外界无法修改value的值。</p>
<p>但仅凭private和final是无法保证String的不可变的：<a href="#final-ref">final的特性</a>；</p>
<p>如果类本身提供修改实例的方法，那也就没有办法保证不变性了，而不可变类的第一条原则就是<strong>不要提供任何会修改对象状态的方法</strong>；</p>
<p>而String类提供的对字符串进行操作的函数，例如：substring、concat、replace等，其中的<strong>每个实现都不会对原有的String实例中的value产生任何影响</strong>，进一步保证了String的不可变。</p>
<h4 id="String常量池"><a href="#String常量池" class="headerlink" title="String常量池"></a>String常量池</h4><p>JVM为了提高字符串的<code>复用性</code>，减少字符串对象的重复创建，特别维护了一个字符串的<code>字面量常量池</code>。</p>
<p>常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，运行期间也有可能将新的常量放入池中。在 Java 虚拟机规范中把方法区描述为堆的一个逻辑部分，但它却有一个别名叫 <code>Non-Heap</code>，目的应该是为了和 Java 堆区进行区分。</p>
<p>例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// output =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// output =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>例1中的输出为<code>false</code>，<code>==</code>在比较基本数据类型时比较的是值，而在比较引用类型时比较的是引用指向的内存地址；使用<code>new</code>关键字时，会直接在堆中生成一个新的String对象，不会去查找常量池中是否存在这个值，所以本质上例1中的<code>str1</code>和<code>str2</code>指向的内存地址是不一样的。</p>
<p>例2之所以为<code>true</code>，是因为例2中的写法会先在字面量常量池中查找是否存在值<code>123</code>，若存在直接返回这个值的引用，若不存在则创建一个值为<code>123</code>的String对象并存入字面量常量池中；而由于String的不可变和字面量常量池的特性，在对<code>str2</code>进行二次修改时，如果常量池中不存在修改的目标值，则会新建一个对象，不会对<code>str1</code>造成影响，保证了数据之间的安全。</p>
<p>使用<code>new</code>生成的String对象也可以放入字面量常量池，String类提供了一个native方法<code>intern()</code>用来将对象的值放入常量池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">str2=str2.intern();</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// output =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>上面的输出为 <code>true</code>。<code>str2</code> 调用 <code>intern()</code> 函数后，首先在字符串常量池中寻找是否存在值为 <code>123</code> 的对象，若存在直接返回该对象的引用，若不存在，加入 <code>str2</code> 并返回。上述代码中，常量池中已经存在值为 <code>123</code> 的 <code>str1</code> 对象，则直接返回 <code>str1</code> 的引用地址，使得 <code>str1</code> 和 <code>str2</code> 指向同一个内存地址。</p>
<h4 id="不可变类的好处"><a href="#不可变类的好处" class="headerlink" title="不可变类的好处"></a>不可变类的好处</h4><p>Effective Java中总结了不可变类的特点：</p>
<ul>
<li><strong>不可变类比较简单。</strong></li>
<li><strong>不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地共享。</strong></li>
<li><strong>不仅可以共享不可变对象，甚至可以共享它们的内部信息。</strong></li>
<li><strong>不可变对象为其他对象提供了大量的构建。</strong></li>
<li><strong>不可变类唯一的缺点是：对于每个不同的值都需要一个单独的对象。</strong></li>
</ul>
<p>而String不可变最重要的原因，就是<strong>安全</strong>。</p>
<p>来看一个HashSet用StringBuilder做元素的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HashSet&lt;StringBuilder&gt; hs=<span class="keyword">new</span> HashSet&lt;StringBuilder&gt;();</span><br><span class="line">        StringBuilder sb1=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        StringBuilder sb2=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;aaabbb&quot;</span>);</span><br><span class="line">        hs.add(sb1);</span><br><span class="line">        hs.add(sb2);    <span class="comment">//这时候HashSet里是&#123;&quot;aaa&quot;,&quot;aaabbb&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">        StringBuilder sb3=sb1;</span><br><span class="line">        sb3.append(<span class="string">&quot;bbb&quot;</span>);  <span class="comment">//这时候HashSet里是&#123;&quot;aaabbb&quot;,&quot;aaabbb&quot;&#125;</span></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//[aaabbb, aaabbb]</span></span><br></pre></td></tr></table></figure>

<p>StringBuilder型变量sb1和sb2分别指向了堆内的字面量”aaa”和”aaabbb”。</p>
<p>把他们都插入一个HashSet，到这一步没问题。但如果后面把变量sb3也指向sb1的地址，再改变sb3的值，因为StringBuilder没有不可变性的保护，sb3直接在原先”aaa”的地址上进行修改，导致sb1的值也变了。这时候，HashSet上就出现了两个相等的键值”aaabbb”。<strong>破坏了HashSet键值的唯一性</strong>。所以<strong>千万不要用可变类型做HashMap和HashSet键值。</strong></p>
<p>还有一个就是在并发场景下，多个线程同时读一个资源，是不会引发竟态条件的。只有对资源做写操作才有危险。<strong>不可变对象不能被写，所以线程安全</strong>。</p>
<h4 id="String是否真的不可变"><a href="#String是否真的不可变" class="headerlink" title="String是否真的不可变"></a>String是否真的不可变</h4><p>String的确是个不可变类，但反射可以做到很多通常情况下做不到的事情，来看下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">Field field = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);    <span class="comment">// 通过反射直接获取value数组</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);    <span class="comment">// 将value设为可访问状态</span></span><br><span class="line"><span class="comment">// get：返回指定对象上此Field表示的字段的值。 如果值具有原始类型，则该值将自动包装在一个对象中。</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) field.get(str);    <span class="comment">// 获取str对象中的value</span></span><br><span class="line">value[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;    <span class="comment">// 修改value数组</span></span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">//  ↓</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 133</span></span><br></pre></td></tr></table></figure>

<p>通过以上代码，即可通过反射破坏String的不可变性。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>除了 String 类，系统类库中还提供了一些其他的不可变类，基本类型的包装类、BigInteger、BigDecimal等等。这些不可变类比可变类更加易于设计、实现和使用，不容易出错且更加安全。另外，要记住并不仅仅是靠一个 <code>final</code> 关键字来实现不可变的，更多的是靠类内部的具体实现细节。</p>
<hr>
<h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><p>String跟另外两个类的区别是：</p>
<blockquote>
<p> String是final类型，每次声明的都是不可变的对象；由于不可变的特性，String是线程安全的，每次更改都会产生并返回新的String对象。</p>
</blockquote>
<p>StringBuffer、StringBuilder都是可变的，两者都可以在原有的对象上进行操作，所以如果需要经常改变字符串的内容，则建议采用这两个类。</p>
<p>StringBuffer和StringBuilder：</p>
<p>StringBuffer是线程安全的，StringBuilder则是线程不安全的，而线程不安全带来的好处就是效率更高。</p>
<h4 id="什么时候考虑线程安全"><a href="#什么时候考虑线程安全" class="headerlink" title="什么时候考虑线程安全"></a>什么时候考虑线程安全</h4><p>思考：</p>
<p>什么情况下，我们才会考虑线程安全的问题？</p>
<blockquote>
<p>当多个线程同时访问同一个资源时，我们才会考虑线程安全的问题。</p>
</blockquote>
<p>开发中，我们通常用StringBuilder来解决什么问题？</p>
<blockquote>
<p>通常我们使用StringBuilder来处理字符串拼接和修改等问题。</p>
</blockquote>
<p>我们一般在哪里使用StringBuilder？</p>
<blockquote>
<p>我们一般只会在方法内创建StringBuilder来使用。</p>
</blockquote>
<p>基于上述思考，再来设想一个实际场景：</p>
<p>在一个并发场景下，多个线程来调用service层中的某一个方法，例如<code>add()</code>，我们在这个方法中<code>new</code>了一个StringBuilder；每个线程调用这个方法时，都会在栈中生成一个单独的栈帧，因此每个线程都会独享一个StringBuilder，这种情况下并不会造成多个线程同时访问一个StringBuilder，因此不会产生边界问题，这种情况下，我们可以放心的使用StringBuilder。</p>
<p>在实际开发中，我们会优先采用StringBuilder：</p>
<blockquote>
<p>StringBuilder &gt; StringBuffer &gt; String</p>
<ul>
<li>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。</li>
</ul>
</blockquote>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>胧
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://hazykam.github.io/2021/10/18/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Java知识点">https://hazykam.github.io/2021/10/18/Java知识点/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag">
                <i class="fa fa-tag"></i> Java
              </a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/" rel="next" title="数据结构笔记">
      数据结构笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">面向对象的三大特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E3%80%81JRE%E5%92%8CJVM%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">JDK、JRE和JVM的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-text">final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals%E5%92%8ChashCode%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">equals和hashCode的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB"><span class="nav-text">不可变类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-text">String的不可变性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">String源码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">String常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">不可变类的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-text">String是否真的不可变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">String、StringBuffer、StringBuilder的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%80%83%E8%99%91%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">什么时候考虑线程安全</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="胧"
      src="https://portrait.gitee.com/uploads/avatars/user/2852/8558826_hazykam_1610350815.png">
  <p class="site-author-name" itemprop="name">胧</p>
  <div class="site-description" itemprop="description">echo 'Set free'</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hazyKam" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hazyKam" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hazykam@qq.com" title="E-Mail → mailto:hazykam@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-yin-yang"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
