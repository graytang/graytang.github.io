<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ANSWER-42</title>
  
  <subtitle>但愿长醉不复醒</subtitle>
  <link href="https://hazykam.github.io/atom.xml" rel="self"/>
  
  <link href="https://hazykam.github.io/"/>
  <updated>2021-10-20T05:19:33.058Z</updated>
  <id>https://hazykam.github.io/</id>
  
  <author>
    <name>胧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL/MyBatis知识点</title>
    <link href="https://hazykam.github.io/2021/10/20/MySQL%20MyBatis%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://hazykam.github.io/2021/10/20/MySQL%20MyBatis%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-10-20T05:05:39.000Z</published>
    <updated>2021-10-20T05:19:33.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="MyBatis的优缺点"><a href="#MyBatis的优缺点" class="headerlink" title="MyBatis的优缺点"></a>MyBatis的优缺点</h4><p>优点：</p><ol><li>基于SQL语句编程，非常灵活，不会对应用程序或数据库的现有设计造成影响，SQL语句可以写在XML文件中，解除SQL语句与逻辑代码的耦合，便于统一管理；提供特殊的XML标签，支持编写动态SQL，同时支持SQL重用。</li><li>与JDBC相比，不需要手动创建并开关连接，减少了大量的冗余代码。</li><li>与多种数据库的兼容性都很好，MyBatis使用JDBC连接数据库，所以只要JDBC支持的数据库MyBatis都支持。</li><li>能够与Spring很好的集成。</li><li>提供映射标签，支持对象与数据库的ORM对象关系映射，方便对象关系组件维护。</li></ol><p>缺点：</p><ol><li>SQL语句的编写工作量较大，尤其是字段、关联表较多时，对开发人员编写SQL语句的功底有一定要求。</li><li>由于不同的数据库都会有不同的SQL方言，导致数据库移植性差，不能随意更换数据库。</li></ol><span id="more"></span><h4 id="MyBatis与Hibernate的区别"><a href="#MyBatis与Hibernate的区别" class="headerlink" title="MyBatis与Hibernate的区别"></a>MyBatis与Hibernate的区别</h4><blockquote><p>hibernate是Table与对象的映射，适合于面向对象开发，实体清晰时适合使用；</p><p>mybatis是sql与对象的映射，统计查询时适合使用。</p><p>hibernate主要是配置实体关系，查询实体；</p><p>mybatis主要是写sql；</p><p>Mybatis由于所有SQL都是依赖数据库书写的，所以扩展性，迁移性比较差。</p></blockquote><ul><li>开发速度的对比：</li></ul><p>Hibernate的真正掌握要比Mybatis难些。Mybatis框架相对简单很容易手，但也相对简陋些。</p><p>比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：</p><p>一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句,这就节省了大量的时间；</p><p>但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。</p><ul><li>开发工作量的对比：</li></ul><p>Hibernate和MyBatis都有相应的代码生成工具，可以生成简单基本的DAO层方法。</p><p>针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap的映射；而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。</p><ul><li>SQL优化方面</li></ul><p>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。</p><p>Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性，而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。</p><p>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。</p><p>MyBatis的SQL是自己手动写的所以方便调整，但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p><ul><li>对象管理的对比：</li></ul><p>Hibernate是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的JDBC/SQL持久层方案中需要管理SQL语句，Hibernate采用了更自然的面向对象的视角来持久化Java应用中的数据。</p><p>换句话说，使用Hibernate的开发者应该总是关注对象的状态（state），不必考虑SQL语句的执行，这部分细节已经由Hibernate掌管了，只有开发者在进行系统性能调优的时候才需要进行了解，而MyBatis在这一 块没有文档说明，用户需要对对象自己进行详细的管理。</p><ul><li>缓存机制对比：</li></ul><p>相同点：都可以实现自己的缓存或使用其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</p><p>不同点：Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表对象映射中配置是哪种缓存。</p><p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p><p>两者比较：因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL，所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p><p>而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，需要避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p><blockquote><p>Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快。</p><p>Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要经验和能力都很强才行。</p><p>MyBatis入门简单，即学即用，提供了数据库查询的自动对象绑定功能，且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。</p><p>MyBatis的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</p></blockquote><h4 id="‘-’和‘-’的区别"><a href="#‘-’和‘-’的区别" class="headerlink" title="‘#{}’和‘${}’的区别"></a>‘#{}’和‘${}’的区别</h4><p>‘#{}’是预编译处理、是占位符，${}是字符串替换、是拼接符。</p><p>Mybatis在处理‘#{}’时，会将sql中的‘#{}’替换为?，调用PreparedStatement来赋值；</p><p>在处理${}时，只是将${}替换成变量的值，调用Statement赋值。</p><p>‘#{}’的变量替换是在DBMS中的，变量替换后‘#{}’对应的变量会自动加上<code>&#39;&#39;</code>单引号；</p><p>${}的变量替换在DBMS外，变量替换后对应的变量不会加上单引号。</p><p>使用‘#{}’可以有效地防止SQL注入，提高系统安全性。</p><h4 id="Mybatis的插件运行原理"><a href="#Mybatis的插件运行原理" class="headerlink" title="Mybatis的插件运行原理"></a>Mybatis的插件运行原理</h4><p>Mybatis只支持针对<strong>ParameterHandler</strong>、<strong>ResultSetHandler</strong>、<strong>StatementHandler</strong>、<strong>Executor</strong>这4种接口的插件。Mybatis的插件其实是基于JDK的动态代理实现的<strong>拦截器</strong>，为需要拦截的接口生成代理对象，以实现接口方法的拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是<strong>InvocationHandler</strong>的**invoke()**方法，拦截指定的方法。</p><p>编写插件：实现Mybatis的Interceptor接口并重写intercept()方法，然后再给插件加上**@Intercepts<strong>注解，在@Intercepts中使用</strong>@Signature**指定要拦截哪一个接口的哪些方法；启用插件则需要加上@Component注解，或是在配置文件中配置插件，使其加入IoC容器即可。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">    @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span></span><br><span class="line"><span class="meta">    @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span></span><br><span class="line"><span class="meta">    @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)</span></span><br><span class="line"><span class="meta">            &#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"> </span><br><span class="line">invocation.proceed();    <span class="comment">// 使用Mybatis拦截器提供的invocation对象，调用proceed()方法才会执行原有方法的业务逻辑</span></span><br></pre></td></tr></table></figure><hr><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h4><p>索引用来快速地寻找那些具有特定值的记录，如果没有索引，一般在执行查询时会遍历整张表。</p><p>索引的原理：就是把无序的数据变成有序的查询</p><ol><li><p>把创建了索引的列的内容进行排序</p></li><li><p>对排序结果生成<strong>倒排表</strong></p><blockquote><p>一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。<br>而Inverted Index指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。</p></blockquote></li><li><p>在倒排表的内容中加入数据的地址链</p></li><li><p>在查询时，先拿到倒排表内容，再取出数据地址链，从而查找到具体的数据</p></li></ol><h4 id="MySQL聚簇索引和非聚簇索引的区别"><a href="#MySQL聚簇索引和非聚簇索引的区别" class="headerlink" title="MySQL聚簇索引和非聚簇索引的区别"></a>MySQL聚簇索引和非聚簇索引的区别</h4><p>聚簇索引和非聚簇索引都使用B+树作为数据结构。</p><ul><li>聚簇索引：将数据和索引放在一起，且有一定的顺序。数据的物理存放顺序与索引顺序是一致的，找到索引的同时也找到了数据。只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘中的。</li><li>非聚簇索引：叶子节点不存放数据，而是存放数据行的地址。类似于目录，根据索引找到数据行的地址后再到指定的磁盘地址获取数据。</li></ul><blockquote><p>聚簇索引的优势：</p><ol><li>查询通过聚簇索引可以直接获取数据；非聚簇索引查询时，在非覆盖索引（即不只查询索引列，还查询其他数据）的情况下需要二次查询。</li><li>聚簇索引对于范围查询的效率很高，因为数据是有序排列的。</li><li>聚簇索引适合用在需要排序的场合。</li></ol><p>劣势：</p><ol><li>维护索引的成本很高，特别是在插入新行或主键被更新导致要分页（page split）的时候。在大量插入新行后，需要在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行可能会产生磁盘碎片。使用独享表空间可以弱化碎片。</li><li>表如果使用UUID（随机ID）作为主键使数据的存储地址变得稀疏，就可能导致聚簇索引比全表扫描更慢，MySQL官方建议使用auto_increment形式的int类型作为主键。</li><li>如果主键占用的空间比较大，那辅助索引（二级索引；非聚簇索引形式）也会很大，因为辅助索引的叶子节点存储的是主键值；过长的主键值会占用更多的磁盘空间。</li></ol></blockquote><p>InnoDB中一定有主键，主键一定是聚簇索引；不手动设置主键时，则会使用unique索引，如果没有unique索引，则会使用数据库内部的一个隐藏的行id当作主键索引。</p><p>基于主键创建的索引称为二级索引或辅助索引，辅助索引访问数据总是需要二次查找。</p><p>非聚簇索引都是辅助索引，如复合索引、前缀索引、唯一索引、辅助索引的叶子节点存储的是主键的值。</p><p>MyISAM使用的是非聚簇索引，没有聚簇索引。</p><p>非聚簇索引的两颗B+树非常相似，节点的结构完全一致，只是存储的内容不同，主键索引的B+树节点存储了主键值，辅助索引的B+树存储了辅助键值，表数据则存储在独立的空间。</p><p>两颗B+树的叶子节点都使用一个地址指向表数据，对于表数据来说两个键没有任何区别。</p><p>由于索引树是独立的，通过辅助键建所无需访问主键的索引树。</p><p>如果涉及数据量很大的排序、全表扫描、count之类的操作，MyISAM会更有优势，因为索引占用的空间小，这些操作都是需要在内存中执行的。</p><h4 id="MySQL索引的数据结构以及优劣"><a href="#MySQL索引的数据结构以及优劣" class="headerlink" title="MySQL索引的数据结构以及优劣"></a>MySQL索引的数据结构以及优劣</h4><p>索引的数据结构和存储引擎的实现油管，在MySQL中使用较多的索引有B+树索引、Hash索引等，InnoDB的默认索引实现为B+树索引。</p><p>Hash索引底层的数据结构就是HashMap，在需求为绝大多数查询都是单条记录查询时，可以选择Hash索引，单条查询性能最高；其余大部分场景，建议选择B+树索引。</p><blockquote><p>B+树：</p><p>B+树是一个平衡的多叉树，从根节点到叶子节点的深度不超过1（自上而下为深度，自下而上为高度），且同层级的节点之间存在双向指针。</p><p>B+树的常规检索中，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序查询时，也可以利用双向指针快速移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</p></blockquote><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241438779.jpg"></p><blockquote><p>Hash索引：</p><p>Hash索引的底层结构是HashMap，采用指定的Hash算法将键值替换为Hash值，检索时不需要像B+树一样从根节点到叶子节点逐级查找，只需要一次Hash算法即可定位到相应的位置，速度非常快。</p></blockquote><p>等值查询时hash索引有绝对优势，前提是键值都是唯一的，如果键值不唯一，就需要先找到键的所在位置，再根据链表向后查找，直到查找到相应的数据；</p><p>在需要对范围进行查询检索时，hash索引就无法使用了，原本有序的键值在经过hash算法后会丢失顺序，也就没办法利用索引进行范围查询了。</p><p>hash索引也没办法利用索引排序，以及like ‘xx%’这样的部分模糊查询（这种部分模糊查询本质上也是范围查询）。</p><p>hash索引也不支持多列联合索引的最左匹配规则。</p><p>在有大量重复的键值时，hash索引也会因为hash碰撞导致效率降低。</p><p>B+树索引的关键字检索效率比较平均，不像B树波动幅度大。</p><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><p>索引定义：是一个单独的，存储在磁盘上的数据库结构，其包含着对数据表里所有记录的引用指针。为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。</p><ol><li><p><strong>选择唯一性索引</strong></p><p> 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</p><p> 例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p></li><li><p><strong>为经常需要排序、分组和联合操作的字段建立索引</strong></p><p> 经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p></li><li><p><strong>为经常作为查询条件的字段建立索引</strong></p><p> 如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此为这样的字段建立索引，可以提高整个表的查询速度。</p></li><li><p><strong>定义了外键的数据列一定要建立索引</strong></p></li><li><p><strong>更新频繁的字段不适合创建索引</strong></p></li><li><p><strong>限制索引的数量</strong></p><p> 索引不是越多越好。每个索引都需要占用额外的磁盘空间，索引越多，需要的磁盘空间就越大，同时会降低写操作的性能。修改表时，对索引的重构和更新成本很高，索引越多，更新表的时间越长。</p></li><li><p><strong>尽量使用数据量少的索引</strong></p><p> 如果索引的值比较大，查询的速度就会受到影响。例如，对一个CHAR(100)类型的字段进行全文<br> 检索需要的时间，肯定要比对CHAR(10)类型的字段需要的时间要多。</p></li><li><p><strong>尽量使用短索引</strong></p><p> 如果索引字段的值很长，应该指定一个定长的前缀，使用值的前缀来索引，这样能够节省大量的索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检索其余行是否匹配。</p></li><li><p><strong>尽量扩展索引，不要新建索引</strong></p><p> 比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></li><li><p><strong>即时删除不再使用或者很少使用的索引</strong></p><p>表中的数据被大量更新，或数据的使用方式被改变后，原有的一些索引可能不再需要，DBA应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p></li><li><p><strong>对于定义为TEXT、IMAGE和BIT数据类型的列不要建立索引</strong></p></li><li><p><strong>记录很少的表不应建立索引</strong></p><p>记录较少的表，索引效果较差，没有必要建立索引。</p></li></ol><h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>基于锁的属性分类：共享锁、排他锁</p><p>基于锁的粒度分类：行锁（InnoDB）、表锁（InnoDB、MyISAM）、页锁（BDB引擎）、记录锁、间隙锁、临键锁</p><p>基于锁的状态分类：意向共享锁、意向排他锁</p><ul><li><p>共享锁（Share Lock）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共享锁也称读锁、S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能加写锁，直到所有的读锁释放之后其他事务才能对其加写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不允许修改，避免出现重复读的问题。</span><br></pre></td></tr></table></figure></li><li><p>排他锁（Exclusive Lock）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排他锁又称写锁、X锁；当一个事务为数据加上写锁时，其他请求不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据加锁。排他锁的目的是在数据修改时，不允许其他请求同时读写，避免出现脏数据和脏读的问题。</span><br></pre></td></tr></table></figure></li><li><p>表锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表锁是指上锁的时候锁住的是整张表，当下一个事务访问该表的时候，必须等上一个事务释放表锁才能访问表。</span><br><span class="line">特点：粒度大，加锁简单，容器冲突。</span><br></pre></td></tr></table></figure></li><li><p>行锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁值上锁时锁住表的某一行或多行记录，其他事务访问同一张表时，除了被锁住的记录，其他记录均可正常访问。</span><br><span class="line">特点：粒度小，开销大加锁慢，会出现死锁；但不容易冲突，相比表锁并发度更高。</span><br></pre></td></tr></table></figure></li><li><p>记录锁（Record Lock）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">记录锁属于行锁的一种，但记录锁只会锁住某一条记录，只有当访问的条件字段是唯一索引列或主键，且被命中时才会触发记录锁。</span><br><span class="line">记录锁可以避免数据在查询时被修改的重复读，以及在修改事务未提交时被其他事务读取的脏读问题。</span><br></pre></td></tr></table></figure></li><li><p>页锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页锁是MySQL中粒度介于行锁和表锁中间的一种锁。表锁速度快冲突多，行锁冲突少速度慢，页锁则是折中了一下，加锁时会锁定相邻的一组记录。</span><br><span class="line">特点：开销和加锁时间介于表锁和行锁之间，会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</span><br></pre></td></tr></table></figure></li><li><p>间隙锁（Gap Lock）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属于行锁的一种；</span><br><span class="line">间隙锁要么封锁索引记录中的间隔，要么锁住第一个索引记录前面的值或者最后一个索引记录后面的值。</span><br><span class="line">当我们采用范围条件查询数据时，InnoDB会对这个范围内的数据进行加锁。比如有id为：1、3、5、7的4条数据，我们查找1-7范围的数据。那么1-7都会被加上锁，2、4、6 也在1-7的范围中，但是不存在这些数据记录，这些2、4、6就被称为间隙。</span><br><span class="line">范围查找时，会把整个范围的数据全部锁定住，即便这个范围内不存在的一些数据，也会被锁定住，比如我要在1、3、5、7中插入2，这个时候1-7都被锁定住了，就无法插入2。</span><br><span class="line">触发条件：在Repeatable Read（可重复读）级别下，范围查询并且查询未命中记录，查询条件必须命中索引。</span><br><span class="line">作用：防止在事务并发时产生的幻读。</span><br></pre></td></tr></table></figure></li><li><p>临键锁（Next-Key Lock）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行锁的一种，并且是InnoDB的默认行锁算法，结合了记录锁和间隙锁的特性，临键锁的封锁范围，既包含索引记录，又包含索引区间。触发条件：范围查询并命中记录，查询条件命中了索引。作用：避免在范围查询时出现脏读、重复读、幻读，加了临键锁后，范围区间内数据不允许被修改和插入。</span><br></pre></td></tr></table></figure></li></ul><p><strong>锁的状态</strong></p><p>如果当事务A加锁成功后设置了一个状态告诉后来的事务，已经对表里的行加了一个排他锁了，无法再对整张表加共享锁或排他锁，那么后来的需要整表加锁的事务只需要获取这个状态就可以知道是否可以对该表加锁，避免了对整个索引树的每个节点扫描是否加锁，这个状态就是意向锁。</p><ul><li><p>意向共享锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事务试图对整张表加共享锁之前，首先需要获得这个表的意向共享锁。</span><br></pre></td></tr></table></figure></li><li><p>意向排他锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事务试图对整张表加排他锁之前，首先需要获得这个表的意向排他锁。</span><br></pre></td></tr></table></figure></li></ul><h4 id="MySQL执行计划参数"><a href="#MySQL执行计划参数" class="headerlink" title="MySQL执行计划参数"></a>MySQL执行计划参数</h4><p>MySQL中，在select语句前加上“explain”或“desc”关键字，即可查看该查询语句的执行计划，分析执行计划是优化SQL的重要手段。</p><p>输出参数：</p><ul><li><p>id<br>  select 查询序列号<br>  id相同，执行顺序由上至下；id不同，id值越大优先级越高，越先被执行</p></li><li><p>select_type<br>  查询数据的操作类型，有如下</p><blockquote><ul><li>simple<br>  简单查询，不包含子查询或union</li><li>primary<br>  包含复杂的子查询，最外层查询标记为该值</li><li>subquery<br>  在select或where里包含子查询，被标记为该值</li><li>derived<br>  在from列表中包含的子查询被标记为该值，MySQL会递归执行这些子查询，把结果放在临时表</li><li>union<br>  若第二个select出现在union之后，则被标记为该值<br>  若union包含在from的子查询中，外层select被标记为derived</li><li>union result<br>  从union表获取结果的select</li></ul></blockquote></li><li><p>table<br>  显示该行数据是关于哪张表</p></li><li><p>partitions<br>  匹配的分区</p></li><li><p>type<br>  表的连接类型，其值、性能由高到底排列如下</p><blockquote><ul><li>system<br>  表只有一行记录，相当于系统表</li><li>const<br>  通过索引一次就找到，只匹配一行数据</li><li>eq_ref<br>  唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配<br>  常用于主键或唯一索引扫描</li><li>ref<br>  非唯一性索引扫描，返回匹配某个单独值的所有行<br>  用于=、&lt; 或 &gt; 操作符带索引的列</li><li>range<br>  只检索给定范围的行，使用一个索引来选择行<br>  一般使用between、&gt;、&lt;</li><li>index<br>  只遍历索引树</li><li>ALL<br>  全表扫描，性能最差</li></ul></blockquote><p>  前5种情况都是理想的索引的情况。通常优化至少到range级别，最好能优化到ref。</p></li><li><p>possible_keys<br>  指出 MySQL 使用哪个索引在该表找到行记录。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能</p></li><li><p>key<br>  显示 MySQL 实际使用的索引。如果为 NULL，则没有使用索引查询</p></li><li><p>key_len<br>  表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度</p></li><li><p>ref<br>  显示该表的索引字段关联了哪张表的哪个字段</p></li><li><p>rows<br>  根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好</p></li><li><p>filtered<br>  返回结果的行数占读取行数的百分比，值越大越好</p></li><li><p>extra<br>  包含不适合在其他列中显示但十分重要的额外信息。常见的值如下</p><blockquote><ul><li>using filesort<br>  MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取<br>  <strong>若出现有该值，应该优化SQL语句</strong></li><li>using temporary<br>  使用临时表保存中间结果，比如，MySQL在对查询结果排序时使用临时表<br>  常见于order by和group by<br>  <strong>若出现有该值，应该优化SQL语句</strong></li><li>using index<br>  表示select操作使用了覆盖索引，避免了访问表的数据行，效率不错</li><li>using where<br>  where 子句用于限制哪一行</li><li>using join buffer<br>  使用连接缓存</li><li>distinct<br>  发现第一个匹配后，停止为当前的行组合搜索更多的行</li></ul></blockquote></li></ul><h4 id="如何处理慢查询"><a href="#如何处理慢查询" class="headerlink" title="如何处理慢查询"></a>如何处理慢查询</h4><p>在业务系统中，除了使用主键继续进行的查询，其他的查询都会在测试库上测试查询耗时，一般会定期统级慢查询。</p><p>慢查询的原因一般有：</p><ul><li>查询了多余不需要的列</li><li>查询条件没有命中索引</li><li>表的数据量太大</li></ul><p>针对这些原因，一般有以下解决方法：</p><ul><li>分析语句是否查询了额外的数据，将多余的列排除掉，重写语句</li><li>分析语句的执行计划，获得索引的使用情况，之后修改语句或索引，使语句尽可能命中索引</li><li>数据量太大时，语句的优化已经无法再进行了，这时可以考虑横向或纵向分表</li></ul><h4 id="事务的原则和隔离级别"><a href="#事务的原则和隔离级别" class="headerlink" title="事务的原则和隔离级别"></a>事务的原则和隔离级别</h4><p><strong>事务原则（ACID）</strong>：</p><ul><li>原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：事务前后数据的正确性必须保持一致。</li><li>隔离性（Isolation）：指一个事务的修改在最终提交前，对其他事务是不可见的。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><p><strong>隔离级别</strong>：</p><ul><li><p>Read Uncommitted：读未提交，可能会读到其他事务<strong>未提交</strong>的数据，也叫脏读。</p><p>  用户本来应该读取到id=1的用户age应该是10，然而读取到了其他事务还没有提交的事务，结果读取到age=20，这就是脏读。</p></li><li><p>Read Committed：读已提交，Oracle的默认级别，两次读取的结果不一致，也叫不可重复读。</p><p>  不可重复读解决了脏读的问题，它只会读取已经提交的事务。</p><p>  用户开启了一个事务读取id=1用户，查询到age=10，再次读取时，因为其他事务对age的修改被提交了，读取结果age=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。</p><p>  如果需要避免不可重复读，可以为事务加读锁。</p></li><li><p>Repeatable Read：可重复读，在RC级别之上，MySQL的默认级别，事务A在读取时，即时事务B对正在读取的记录提交了修改，在事务A没有结束的期间，读到的依然是未被事务B修改前的数据；在范围查询且有数据被插入时，会发生幻读。</p></li><li><p>Serializable：串行化，一般不会使用，它会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</p></li></ul><blockquote><p>脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据。</p><p>不可重复读（Non-repeatable Read）：在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，可能是某些场合不对）</p><p>虚读/幻读（Phantom Read）：是指一个事务内读取到了别的事务插入的数据，导致前后读取不一致。（一般是行影响，会导致多出一行）</p></blockquote><p>MySQL的MVCC机制在RC和RR级别下，会针对select查询生成一个Read View；</p><p>RC级别下事务中每次select都会更新Read View，使得每次有事务提交修改时都会看到修改后的数据；</p><p>而RR级别下一个事务只在第一次select的时候会获取一次Read view，在这个事务未提交前事务中所有的select都会复用这个Read View，这样每次读到的就是一样的，但如果在范围读取时有别的事务提交了一个insert，下一次select时就会将新插入的数据读取出来，从而产生幻读，MySQL的MVCC机制使用了快照读和next-key lock当前读解决了幻读的问题。</p><h4 id="ACID靠什么保证"><a href="#ACID靠什么保证" class="headerlink" title="ACID靠什么保证"></a>ACID靠什么保证</h4><p>原子性由undo log日志保证，undo log记录了需要回滚的日志信息，事务回滚时会执行已成功SQL对应的反向SQL语句。</p><p>一致性由其他三大特性保证，在程序代码中要保证业务上的一致性。</p><p>隔离性由MVCC机制来保证。</p><p>持久性由内存+redo log保证，MySQL修改数据会同时在内存和redo log记录这次操作，宕机时可以从redo log恢复。</p><blockquote><p>InnoDB redo log写盘，InnoDB事务进入prepare状态。</p><p>如果前面prepare成功，bin log写盘，再继续将事务日志持久化到bin log。</p><p>如果持久化成功，那么InnoDB事务则进入commit状态（在redo log中写一个commit记录）</p></blockquote><p>redo log的刷盘会在系统空闲时进行</p><h4 id="MVCC-MCC-多版本并发控制"><a href="#MVCC-MCC-多版本并发控制" class="headerlink" title="MVCC/MCC - 多版本并发控制"></a>MVCC/MCC - 多版本并发控制</h4><p>Multiversion Concurrency Control - 多版本并发控制</p><p>读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不会发生冲突，不同事务session会看到自己特定版本的数据，会有一个版本链的概念。</p><p>MVCC只在RC（读已提交）和RR（可重复读）两个隔离级别下工作，其他两个隔离级别和MVCC不兼容，RU（读未提交）总是读取最新的数据行，而不是符合当前事务版本的数据行，SERIALIZABLE（串行化）则会对所有读取的行都加锁。</p><p>聚簇索引记录中由两个必要的隐藏列：</p><p><strong>trx_id</strong>：用来了存储每次对某条聚簇索引记录进行修改的事务的id。</p><p><strong>roll_pointer</strong>：每次对某条聚簇索引记录修改时，都会将上一个版本写入undo log中。这个roll_pointer存储了一个指针，指向了这条聚簇索引记录的上一个版本的地址，通过它来获得上一个版本的记录信息。（插入操作的undo log没有这个属性，因为insert不存在上一个版本）</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241439590.png"></p><p><strong>读已提交和可重复读的区别就在于他们生成ReadView的策略不同。</strong></p><p>开始事务时创建ReadView，ReadView维护了当前活动的事务id，即未提交的事务id，排序生成一个数组。</p><p>访问数据，获取数据中的事务id（获取的是事务id最大的记录），对比ReadView；</p><p>如果id在ReadView数组的左边（比ReadView中的事务id都小），则意味着该事务已被提交，可以访问。</p><p>如果id在ReadView右边（比ReadView中的事务id都大）或就在ReadView中，则不可以访问，获取roll_pointer，取上一个版本重新对比。（在右边意味着该事务在ReadView生成后才出现，在ReadView中则意味着该事务还未提交）</p><p>RC级别下的事务在每次select开始都会生成一个独立的ReadView，而RR级别则在第一次select时生成一个事务中唯一的ReadView，之后事务中的select都会复用这个事务中唯一的ReadView。</p><p>总结：MySQL的MVCC，通过版本链，实现多版本，可并发读写；通过ReadView生成策略的不同实现不同的隔离级别。</p><h4 id="MySQL主从同步原理"><a href="#MySQL主从同步原理" class="headerlink" title="MySQL主从同步原理"></a>MySQL主从同步原理</h4><p>MySQL的主从复制中主要由三个线程：</p><ul><li>master（binlog dump thread）</li><li>slave（I/O thread、SQL thrad）</li></ul><p>master一条、slave两条</p><p>执行要点：</p><ol><li>主节点binlog，binlog是数据库服务器启动的那一刻起，保存了所有数据库结构或内容变更记录的一个文件。</li><li>主节点log dump线程，当binlog发生更改时，log dump线程会读取其内容并发送给从节点。</li><li>从节点I/O线程接收binlog内容，并将其写入relay log（中继日志）文件中。</li><li>从节点SQL线程读取relay log文件内容，将主库binlog中复制过来的内容在从库上进行重放，最终保证主从数据库的一致性。</li></ol><p>注：主从节点使用binlog文件+position偏移量来定位主从同步的位置，从节点会保存已接收到的偏移量，如果从节点发生宕机重启，则会从position的位置发起同步。</p><blockquote><p>由于MySQL默认的复制方式是异步的，主库将binlog发送给从库后不会关心从库是否已经接收，这样会产生一个，即主库挂了，从库也接收失败了，这时从库升为主库后，log就丢失了，由此产生以下两个概念。</p></blockquote><p><strong>全同步复制</strong></p><p>主库写入binlog后强制同步日志到从库，当所有从库都接收完成返回ACK（Acknowledge character，即确认字符）给主库后，主库才会返回给客户端，但这种方式在从库数量较多时性能会受到严重影响。</p><p><strong>半同步复制</strong></p><p>从库写入relay log后返回ACK给主库，主库只需收到至少一个从库的确认就认为同步操作执行成功。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;MyBatis&quot;&gt;&lt;a href=&quot;#MyBatis&quot; class=&quot;headerlink&quot; title=&quot;MyBatis&quot;&gt;&lt;/a&gt;MyBatis&lt;/h3&gt;&lt;h4 id=&quot;MyBatis的优缺点&quot;&gt;&lt;a href=&quot;#MyBatis的优缺点&quot; class=&quot;headerlink&quot; title=&quot;MyBatis的优缺点&quot;&gt;&lt;/a&gt;MyBatis的优缺点&lt;/h4&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于SQL语句编程，非常灵活，不会对应用程序或数据库的现有设计造成影响，SQL语句可以写在XML文件中，解除SQL语句与逻辑代码的耦合，便于统一管理；提供特殊的XML标签，支持编写动态SQL，同时支持SQL重用。&lt;/li&gt;
&lt;li&gt;与JDBC相比，不需要手动创建并开关连接，减少了大量的冗余代码。&lt;/li&gt;
&lt;li&gt;与多种数据库的兼容性都很好，MyBatis使用JDBC连接数据库，所以只要JDBC支持的数据库MyBatis都支持。&lt;/li&gt;
&lt;li&gt;能够与Spring很好的集成。&lt;/li&gt;
&lt;li&gt;提供映射标签，支持对象与数据库的ORM对象关系映射，方便对象关系组件维护。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SQL语句的编写工作量较大，尤其是字段、关联表较多时，对开发人员编写SQL语句的功底有一定要求。&lt;/li&gt;
&lt;li&gt;由于不同的数据库都会有不同的SQL方言，导致数据库移植性差，不能随意更换数据库。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hazykam.github.io/tags/MySQL/"/>
    
    <category term="MyBatis" scheme="https://hazykam.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>使用natapp实现简易的内网穿透</title>
    <link href="https://hazykam.github.io/2021/10/18/%E4%BD%BF%E7%94%A8natapp%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://hazykam.github.io/2021/10/18/%E4%BD%BF%E7%94%A8natapp%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2021-10-18T09:33:28.000Z</published>
    <updated>2021-10-20T05:09:17.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="让外网访问虚拟机上部署的web项目"><a href="#让外网访问虚拟机上部署的web项目" class="headerlink" title="让外网访问虚拟机上部署的web项目"></a>让外网访问虚拟机上部署的web项目</h2><h3 id="设置端口映射"><a href="#设置端口映射" class="headerlink" title="设置端口映射"></a>设置端口映射</h3><p>在VMware中，编辑 -&gt; 虚拟网络编辑器 -&gt; 选中VMnet8 -&gt;VMnet信息 -&gt; NAT设置 -&gt; 端口转发 -&gt; 添加</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181734046.png"></p><p>虚拟机IP地址可以在Linux中通过<code>ifconfig</code>查看</p><p>虚拟机端口则是项目的启动端口，需要设置对外开放</p><p>主机端口可以指定将虚拟机的IP和端口映射到主机的哪个端口</p><span id="more"></span><p>设置完毕后，在Linux中启动项目，在主机中访问指定的映射端口进行测试</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181734760.png"></p><h3 id="使用NATAPP实现内网穿透"><a href="#使用NATAPP实现内网穿透" class="headerlink" title="使用NATAPP实现内网穿透"></a>使用NATAPP实现内网穿透</h3><p>访问NATAPP官网：<a href="https://natapp.cn/%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%A2%E6%88%B7%E7%AB%AF">https://natapp.cn/，下载客户端</a></p><p>访问网页后台，用户中心 -&gt; 我的隧道，获取authtoken</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181734945.png"></p><p>如果需要更改映射到本地的IP或端口，可以在隧道配置中修改</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181734945.png"></p><p>在<code>natapp.exe</code>同级目录中创建<code>config.ini</code></p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181735785.png"></p><p>配置config.ini，将在网页后台获取到authtoken赋给对应项</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将本文件放置于natapp同级目录 程序将读取 [default] 段</span></span><br><span class="line"><span class="comment">#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置</span></span><br><span class="line"><span class="comment">#命令行参数 -config= 可以指定任意config.ini文件</span></span><br><span class="line"><span class="section">[default]</span></span><br><span class="line">authtoken=                    <span class="comment"># 对应一条隧道的authtoken</span></span><br><span class="line">clienttoken=                    <span class="comment"># 对应客户端的clienttoken,将会忽略authtoken,若无请留空,</span></span><br><span class="line"><span class="attr">log</span>=none                        <span class="comment"># log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为none</span></span><br><span class="line"><span class="attr">loglevel</span>=DEBUG                  <span class="comment"># 日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUG</span></span><br><span class="line">http_proxy=                     <span class="comment"># 代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空</span></span><br></pre></td></tr></table></figure><p>启动在Linux中部署的web项目</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181735710.png"></p><p>运行natapp.exe，Forwarding中的域名会映射到配置的本机端口</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181735098.png"></p><p>测试访问域名，结束</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181735588.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;让外网访问虚拟机上部署的web项目&quot;&gt;&lt;a href=&quot;#让外网访问虚拟机上部署的web项目&quot; class=&quot;headerlink&quot; title=&quot;让外网访问虚拟机上部署的web项目&quot;&gt;&lt;/a&gt;让外网访问虚拟机上部署的web项目&lt;/h2&gt;&lt;h3 id=&quot;设置端口映射&quot;&gt;&lt;a href=&quot;#设置端口映射&quot; class=&quot;headerlink&quot; title=&quot;设置端口映射&quot;&gt;&lt;/a&gt;设置端口映射&lt;/h3&gt;&lt;p&gt;在VMware中，编辑 -&amp;gt; 虚拟网络编辑器 -&amp;gt; 选中VMnet8 -&amp;gt;VMnet信息 -&amp;gt; NAT设置 -&amp;gt; 端口转发 -&amp;gt; 添加&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/graytang/img-repo/raw/master/img/202110181734046.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;虚拟机IP地址可以在Linux中通过&lt;code&gt;ifconfig&lt;/code&gt;查看&lt;/p&gt;
&lt;p&gt;虚拟机端口则是项目的启动端口，需要设置对外开放&lt;/p&gt;
&lt;p&gt;主机端口可以指定将虚拟机的IP和端口映射到主机的哪个端口&lt;/p&gt;</summary>
    
    
    
    <category term="随手笔记" scheme="https://hazykam.github.io/categories/%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="内网穿透" scheme="https://hazykam.github.io/categories/%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    
    <category term="内网穿透" scheme="https://hazykam.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用操作</title>
    <link href="https://hazykam.github.io/2021/10/18/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://hazykam.github.io/2021/10/18/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2021-10-18T09:29:11.000Z</published>
    <updated>2021-10-20T05:08:25.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="Vim的常用模式"><a href="#Vim的常用模式" class="headerlink" title="Vim的常用模式"></a>Vim的常用模式</h3><p><strong>正常模式（命令模式）</strong></p><p>使用vim打开一个文件，默认进入正常模式；正常模式中可以使用上下左右移动光标，可以对文件进行删除字符、删除整行、复制和粘贴等操作。</p><p><strong>插入模式（输入模式）</strong></p><p>按下<code>i</code>后进入插入模式，该模式下可以直接对文件进行编辑，可以使用<code>ESC</code>退回到正常模式。</p><p><strong>命令行模式（底线命令模式）</strong></p><p>在正常模式下输入<code>:</code>进入命令行模式，该模式下可以进行读取、保存、替换、退出vim、显示行号等操作。</p><span id="more"></span><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>**==打开文件==**：在Linux终端中输入<code>vim f_name</code>，使用vim打开指定文件，默认为正常模式；</p><p>**==退出vim==**：</p><p><code>:wq</code> - 在命令行模式中输入wq，会写入（保存）文件并退出，可以单独使用<code>w</code>保存文件；</p><p><code>:q</code> - 正常退出；</p><p><code>:q!</code> - 强制退出，不会保存文件，<code>!</code>可以和<code>w</code>之类的命令配合使用；</p><p>**==复制粘贴==**：</p><p><strong>单行复制</strong> - 在正常模式中输入<code>yy</code>，拷贝当前光标所在行；</p><p><strong>多行复制</strong> - 输入<code>rowNum+yy</code>，拷贝包括光标所在行的rowNum行；例如<code>3yy</code>，复制光标所在行和所在行的下方两行，共三行；</p><p><strong>粘贴</strong> - 移动光标到需要粘贴的位置，输入<code>p</code>，完成粘贴；</p><p>==<strong>删除</strong>==：</p><p><strong>单行删除</strong> - 输入<code>dd</code>，删除当前光标所在行；</p><p><strong>多行删除</strong> - <code>rowNum+dd</code>，和多行复制相同的逻辑；</p><p>==<strong>查找关键字</strong>==：</p><p><strong>顺序查找</strong></p><p>在正常模式下输入<code>/</code>进入查找模式，输入对应关键词按下回车进行查找，在查找过程中按下<code>n</code>会匹配下一个，按下<code>N</code>即shift+n匹配上一个；</p><p>重新输入<code>/</code>会清空当前关键字，重新输入关键字再次进行查找，按下退格键删除<code>/</code>退出查找；</p><p>退出查找后，命令行模式输入<code>noh</code>可以取消查找关键字的高亮；</p><p><strong>反向查找</strong> - 输入<code>?</code>进入反向查找，输入关键字并回车后，按下<code>n</code>会匹配上一个；</p><p>==<strong>行号</strong>==：</p><p><strong>显示行号</strong> - 在命令行模式输入<code>set nu</code>，开启行号显示；</p><p><strong>取消显示</strong> - 输入<code>set nonu</code>，关闭行号显示；</p><p>**==首尾行跳转==**：</p><p>正常模式下输入<code>gg</code>使光标跳转到文件首行，输入<code>G</code>使光标跳转到文件尾行；</p><p>**==撤销/重做==**：</p><p><strong>撤销</strong> - 在正常模式下输入<code>u</code>可以撤销之前的动作；</p><p><strong>重做</strong> - 撤销后再输入<code>Ctrl+r</code>可以恢复撤销的动作；</p><p>**==快速跳转==**：在正常模式下，输入<code>rowNum</code>后，再输入<code>shift+g</code>，可以将光标快速移动到指定行；例如：5 -&gt; shift+g，快速跳转到第5行；</p><p>**==翻页==**：</p><p><code>Ctrl+u</code>：向前翻半页；</p><p><code>Ctrl+d</code>：向后翻半页；</p><p><code>Ctrl+b</code>：向前翻一页；</p><p><code>Ctrl+f</code>：向后翻一页。</p><p>其他：</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181724867.gif"></p><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h4 id="关机-amp-重启"><a href="#关机-amp-重启" class="headerlink" title="关机&amp;重启"></a>关机&amp;重启</h4><p><code>shutdown -h now</code>：立即关机，-h代表halt停止，now表示立即</p><p><code>shutdown -h countdown</code>：指定倒计时后关机，countdown表示指定的倒计时，例如：<strong>shutdown -h 1</strong>，指定1分钟后关机；</p><p>可以携带message，例如：**shutdown -h 1 “1分钟后关机”**，携带的message：”1分钟后关机”，会通知到当前所有登录到Linux终端的用户；</p><p><code>shutdown</code>：等效于<strong>shutdown -h 1</strong>；</p><p><code>shutdown -r now</code>：立即重启，-r代表reboot重新启动；</p><p><code>halt</code>：等效于<strong>shutdown -h now</strong>；</p><p><code>reboot</code>：等效于<strong>shutdown -r now</strong>；</p><p><code>sync</code>：==将内存中的数据同步到磁盘，关机或重启前必须运行该命令，防止数据丢失==；</p><h4 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h4><p>cd：change directory</p><p><code>cd ..</code>：返回上一级目录</p><p><code>cd ../..</code>：返回上两级目录</p><p><code>cd或cd ~</code>：返回home目录</p><p><code>cd 目录名</code>：切换指定目录</p><h4 id="当前用户所在目录"><a href="#当前用户所在目录" class="headerlink" title="当前用户所在目录"></a>当前用户所在目录</h4><p>pwd：print work directory</p><p><code>pwd</code>：使用该命令可以显示当前所在的目录的层级；</p><h4 id="列出目录"><a href="#列出目录" class="headerlink" title="列出目录"></a>列出目录</h4><p><code>ls</code>：列出当前目录或指定目录下的文件</p><p>-a 参数：all，查看所有文件，包括隐藏文件</p><p>-l 参数：查看文件详细信息，包含属性和权限，如果想单独使用该参数可以将<code>ls</code>简写成<code>ll</code></p><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p><code>touch 文件</code>：创建一个文件，默认在当前目录下创建，也可以在指定目录下创建，touch的另一个作用是更改一个文件或目录的时间</p><h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h4><p>mkdir：make directory</p><p><code>mkdir 文件夹名称</code>：在当前目录下创建一个文件夹</p><p>-p 参数：创建层级目录，例如：mkdir -p test1/test2/test3</p><h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><p><code>cat 文件名</code>：从第一行开始显示文件内容，用于读取代码或配置等含文本文件</p><p><code>tac 文件名</code>：cat的倒置，从最后一行开始显示</p><p><code>nl 文件名</code>：携带行号显示文件内容，会忽略空行的行号计数</p><p><code>more 文件名</code>：分页显示文件内容，只能向后滚动，空格进入下一页，回车进入下一行，查看过程中使用命令<code>:f</code>可以显示当前页尾行行号，按q退出查看</p><p><code>less 文件名</code>：作用和more类似，但是可以向前滚动，上下键可以前进或后退一行，也可以使用pageUp和pageDown键进行前后翻页，查看过程中可以使用<code>/关键字</code>匹配关键字进行向下查找，<code>?关键字</code>向上查找，使用方式和上下匹配的快捷键和vim一致</p><p><code>head [选项] [行数] 文件名</code>：可以查看文件的头几行，不携带选项参数默认显示10行，可以通过<code>-n</code>参数+行数查看指定的头部几行</p><p><code>tail [选项] [行数] 文件名</code>：查看文件尾部几行，使用方式和head一样</p><h4 id="硬链接-软（符号）链接"><a href="#硬链接-软（符号）链接" class="headerlink" title="硬链接/软（符号）链接"></a>硬链接/软（符号）链接</h4><p>Linux下的链接文件有点类似于Windows中的快捷方式，但是有几点不同，分为硬链接和软链接；</p><p><strong>硬链接</strong>：假设有个A文件，我们对其使用命令创建了一个硬链接B文件。</p><p>对硬链接文件查看文件属性可以看到，硬链接的文件类型列的标识是<code>-</code>，也就是一个普通文件。</p><p>由于硬链接是直接指向物理存储的数据块地址的，所以删除A文件，B文件依然可以读取出文件中原本的内容。</p><p>作用在于允许一个文件拥有多个路径，用户可以通过这种机制对一些重要文件使用硬链接，防止误删。</p><p><strong>软链接</strong>：软链接也称符号链接，就和Windows中的快捷方式完全一样，指向的是源文件，对其查看文件属性也可以看到文件类型列的标识是<code>l</code>，也就是一个单纯的链接文件，删除了源文件后软链接则无法进行访问。</p><p><code>ln [选项] 源文件 链接文件</code>：该命令可以为文件创建链接，默认创建硬链接，使用<code>-s</code>选项参数可以创建软链接。</p><h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><p><code>rm [选项] 文件或目录</code>：删除文件或目录，可以使用正则表达式</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181726212.png"></p><p>“rm -f” 强行删除，忽略不存在的文件，不提示确认。(f为force的意思)<br>“rm -i” 进行交互式删除，即删除时会提示确认。(i为interactive的意思)<br>“rm -r” 将参数中列出的全部目录和子目录进行递归删除。(r为recursive的意思)<br>“rm -v” 详细显示删除操作进行的步骤。(v为verbose的意思)</p><h4 id="拷贝命令"><a href="#拷贝命令" class="headerlink" title="拷贝命令"></a>拷贝命令</h4><p><code>cp 拷贝文件 目标目录</code>：拷贝文件到目标目录中</p><h4 id="移动-重命名文件"><a href="#移动-重命名文件" class="headerlink" title="移动/重命名文件"></a>移动/重命名文件</h4><p><code>mv [选项] 源文件... 目的地/</code>：移动文件到指定目录</p><ul><li><strong>-b</strong>: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li><li><strong>-i</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</li><li><strong>-f</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li><li><strong>-n</strong>: 不要覆盖任何已存在的文件或目录。</li><li><strong>-u</strong>：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li></ul><p>mv命令可以在移动时修改文件名，例如：mv test.txt dir/test2.txt</p><p>mv命令同样可以直接重命名文件，例如：mv test.txt test2.txt或mv dir dir2</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>Linux输入的参数过长时，可以在行尾使用<code>\</code>反斜杠+回车换行，代表下一行是续行。</p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在包所在的目录下解压</span></span><br><span class="line">tar -zxvf tar包名.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压至指定目录</span></span><br><span class="line">tar -zxvf tar包名.tar.gz -C 目录</span><br></pre></td></tr></table></figure><h4 id="用户登录-amp-注销"><a href="#用户登录-amp-注销" class="headerlink" title="用户登录&amp;注销"></a>用户登录&amp;注销</h4><ol><li>登录时尽量不要直接使用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用<code>su root</code>命令来切换成系统管理员身份。</li><li>在终端下输入<code>logout</code>即可注销用户。</li></ol><p>注意：logout注销指令在图形运行级别无效，在运行级别3下有效。</p><h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h4><blockquote><p>0： 系统停机（关机）模式，系统默认运行级别不能设置为0，否则不能正常启动，一开机就自动关机。</p><p>1：单用户模式，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。</p><p>2：多用户模式，没有NFS网络支持。</p><p>3：完整的多用户终端模式，有NFS，登陆后进入终端模式。</p><p>4：系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。</p><p>5：图形化模式，登陆后进入图形GUI模式或GNOME、KDE图形化界面，如X Window系统。</p><p>6：重启模式，默认运行级别不能设为6，否则不能正常启动，就会一直开机重启开机重启。</p></blockquote><h4 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h4><p><code>init 运行级别</code>：使用该指令可以切换当前系统运行级别，该指令不会更改默认的运行级别；</p><p><strong>设置默认运行级别</strong></p><p>CentOS 7以后，将运行级别进行了简化：</p><p>multi-user.target - 运行级别3</p><p>graphical.target - 运行级别5</p><p><code>systemctl get-default</code>：使用该指令可以获得当前系统默认运行级别；</p><p><code>systemctl set-default TARGET.target</code>：使用该指令可以指定系统默认的运行级别，例如：<code>systemctl set-default multi-user.target</code>，将默认运行级别指定为3；</p><h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4><p><code>man 命令或配置文件</code>：使用该命令可以获得帮助信息，例如：<code>man ls</code>，可以获得ls指令的帮助信息；</p><p><code>help 命令</code>：该指令可以获得shell内置命令的帮助信息；</p><p>tip：命令帮助信息中显示的选项参数可以组合使用，例如：<code>ls -la</code>；</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><p><code>useradd u_name</code>：使用该命令可以创建一个用户，创建用户后会默认在/home目录下生成一个用户文件夹，文件夹与username同名；</p><p><code>useradd -d dir u_name</code>：-d代表在指定目录下生成用户文件夹，dir表示指定目录路径；</p><h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><p><code>passwd u_name</code>：该命令可以修改指定用户的密码，如果不携带username参数，则默认为当前用户修改密码；</p><h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><p><code>userdel u_name</code>：使用该命令可以删除指定用户，需要root权限，使用该命令删除用户时不会删除用户文件夹，需要同时删除用户文件夹需要加上参数<code>-r</code>，例如：<code>userdel -r u_name</code>，谨慎使用<code>-r</code>，一般情况下都建议保留用户文件夹；</p><h5 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h5><p><code>id u_name</code>：该指令可以查询指定用户的id和group等信息；</p><h5 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h5><p><code>su u_name</code>：该指令可以切换到指定的用户；</p><p>注意：从权限高的用户切换到权限低的用户，不需要输入密码，相反则需要；当需要返回到之前的用户时，使用exit或logout指令；</p><h5 id="查询首次登录用户"><a href="#查询首次登录用户" class="headerlink" title="查询首次登录用户"></a>查询首次登录用户</h5><p><code>whoami</code>：该指令可以查询我们首次登录系统时使用的是哪个用户；</p><p><code>who am i</code>：作用同上，区别是会显示登录时间和使用哪个IP地址进行登录等信息；</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181726779.png"></p><h5 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h5><p>用户组类似于角色的概念，系统可以将拥有共性或相同权限的多个用户分配到一个组进行统一的管理</p><p><code>groupadd g_name</code>：新增一个指定groupname的组；</p><p><code>groupdel g_name</code>：删除一个指定的组；</p><h5 id="添加用户时指定组"><a href="#添加用户时指定组" class="headerlink" title="添加用户时指定组"></a>添加用户时指定组</h5><p><code>useradd -g g_name u_name</code>：-g参数表示在添加用户时分配组；</p><p>注意：添加用户时如果不分配组，默认会创建一个组名和用户名相同的组，并将用户分配到该组。</p><h5 id="修改指定用户的组"><a href="#修改指定用户的组" class="headerlink" title="修改指定用户的组"></a>修改指定用户的组</h5><p><code>usermod -g g_name u_name</code>：usermod修改用户，携带-g参数时可以修改用户的组；</p><h5 id="用户-组相关文件"><a href="#用户-组相关文件" class="headerlink" title="用户/组相关文件"></a>用户/组相关文件</h5><ul><li><p><strong>/etc/passwd</strong></p><p>  用户配置文件，每行记录对应一个用户，用户又被<code>:</code>分割为7个字段，格式和含义如下：</p><p>  用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</p></li><li><p><strong>/etc/shadow</strong></p><p>  口令配置文件，格式和含义如下：</p><p>  登录用户名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p></li><li><p><strong>/etc/group</strong></p><p>  组配置文件，记录了Linux中组的信息，格式和含义如下：</p><p>  组名:口令:组标识号:组内用户列表</p></li></ul><hr><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>常用的安装方式：rpm包、tar包、yum在线安装</p><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>yum的基本语法：yum [选项] [命令] [包 …]</p><p>选项：</p><p>-h 帮助信息</p><p>-y 安装过程中的提示全部为yes</p><p>-q 不显示安装过程</p><p><strong>常用命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有可更新的软件清单</span></span><br><span class="line">yum check-update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新所有软件</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定软件，可以同时安装多个包，package_name为可变长参数</span></span><br><span class="line">yum install &lt;package_name...&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅更新指定软件</span></span><br><span class="line">yum update &lt;package_name...&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除软件</span></span><br><span class="line">yum remove &lt;package_name...&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找软件包命令</span></span><br><span class="line">yum search &lt;keyword&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除缓存</span></span><br><span class="line">yum clean packages<span class="comment"># 清除缓存目录下的软件包</span></span><br><span class="line">yum clean headers<span class="comment"># 清除缓存目录下的headers</span></span><br><span class="line">yum clean oldheaders<span class="comment"># 清除缓存目录下旧的headers</span></span><br><span class="line">yum clean all<span class="comment"># 清除缓存目录下的软件包以及旧的headers</span></span><br></pre></td></tr></table></figure><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>安装jdk之前，需要检查系统中是否存在openjdk，如果存在需要先卸载openjdk再安装完整的jdk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep jdk <span class="comment"># 查看系统中是否存在已安装的jdk</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep openjdk |xargs rpm -e --nodeps <span class="comment"># 批量卸载命令</span></span><br></pre></td></tr></table></figure><p>使用rpm包安装，默认安装到/usr目录下</p><p>usr：Unix Software Resource</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 包名 <span class="comment"># 使用rpm安装jdk</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181727354.png"></p><p><strong>使用rpm或yum安装JDK无需配置环境变量</strong></p><h3 id="开启对外端口"><a href="#开启对外端口" class="headerlink" title="开启对外端口"></a>开启对外端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看对外开放的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启防火墙对外开放端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=端口号/传输层协议(tcp/udp) --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启防火墙服务</span></span><br><span class="line">systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看对外开放端口，确认端口开启成功</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><h3 id="firewall防火墙常用命令"><a href="#firewall防火墙常用命令" class="headerlink" title="firewall防火墙常用命令"></a>firewall防火墙常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看firewall服务状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动、重启、停止firewalld.service服务</span></span><br><span class="line">service firewalld start</span><br><span class="line">service firewalld restart</span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all<span class="comment"># 查看全部信息</span></span><br><span class="line">firewall-cmd --list-ports<span class="comment"># 只查看端口信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启端口</span></span><br><span class="line">firewall-cmd --zone=作用区域 -add-port=端口号/传输层通讯协议 --permanent<span class="comment"># --permanent代表永久生效，不携带此参数则在重启后失效</span></span><br><span class="line"><span class="comment"># 开启端口后需要重启防火墙以生效</span></span><br><span class="line">systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看firewall的zone</span></span><br><span class="line">firewall-cmd --get-zones</span><br></pre></td></tr></table></figure><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><p>将编译打包好的jar包上传到Linux中，一般会在/opt目录下建个文件夹放置项目；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动项目，测试访问</span></span><br><span class="line">java -jar jar包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动方式，&amp;代表在后台运行，在当前窗口关闭后程序会终止运行</span></span><br><span class="line">java -jar jar包 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># nohup命令可以让程序不挂断运行，当账户推出或终端关闭时，程序依然运行</span></span><br><span class="line"><span class="comment"># 默认情况下使用nohup命令，会将程序的所有输出写到项目当前目录的nohup.out文件中</span></span><br><span class="line">nohub java -jar jar包 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出位置，可以在jar包后面使用&#x27;&gt;&#x27;符号追加日志输出位置和文件名</span></span><br><span class="line">nohub java -jar jar包 &gt;outlog.txt &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不需要输出日志，可以使用如下命令</span></span><br><span class="line">nohub java -jar jar包 &gt;/dev/null &amp;</span><br></pre></td></tr></table></figure><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>将Tomcat的tar.gz包上传至Linux，解压；</p><p>Tomcat的bin目录下的<code>startup.sh</code>和<code>shutdown.sh</code>用于启动和停止tomcat，sh文件是Linux中的可执行bash文件，类似Windows中的exe</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181727146.png"></p><p>启动tomcat，测试是否可以访问成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接启动服务</span></span><br><span class="line">/usr/tomcat目录/bin/startup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh命令启动，使用sh命令可以不需要文件具有可执行属性</span></span><br><span class="line">sh /usr/tomcat目录/bin/startup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">/usr/tomcat目录/bin/shutdown.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># sh停止服务</span></span><br><span class="line">sh /usr/tomcat目录/bin/shutdown.sh</span><br></pre></td></tr></table></figure><p>访问成功，地址栏中的9000端口是因为配置了虚拟机到主机的端口映射</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110181728268.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Vim&quot;&gt;&lt;a href=&quot;#Vim&quot; class=&quot;headerlink&quot; title=&quot;Vim&quot;&gt;&lt;/a&gt;Vim&lt;/h2&gt;&lt;h3 id=&quot;Vim的常用模式&quot;&gt;&lt;a href=&quot;#Vim的常用模式&quot; class=&quot;headerlink&quot; title=&quot;Vim的常用模式&quot;&gt;&lt;/a&gt;Vim的常用模式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;正常模式（命令模式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用vim打开一个文件，默认进入正常模式；正常模式中可以使用上下左右移动光标，可以对文件进行删除字符、删除整行、复制和粘贴等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入模式（输入模式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按下&lt;code&gt;i&lt;/code&gt;后进入插入模式，该模式下可以直接对文件进行编辑，可以使用&lt;code&gt;ESC&lt;/code&gt;退回到正常模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令行模式（底线命令模式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在正常模式下输入&lt;code&gt;:&lt;/code&gt;进入命令行模式，该模式下可以进行读取、保存、替换、退出vim、显示行号等操作。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Linux" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"/>
    
    
    <category term="Linux" scheme="https://hazykam.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx概念入门</title>
    <link href="https://hazykam.github.io/2021/10/18/Nginx%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"/>
    <id>https://hazykam.github.io/2021/10/18/Nginx%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</id>
    <published>2021-10-18T09:15:48.000Z</published>
    <updated>2021-10-18T10:32:09.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径，另外还可以使用缓存的特性减少网络使用率。</p><p>例：</p><p>用户需要访问某个目标网站（如Google），但因为防火墙的存在而无法直接访问，但用户可以访问到一个代理服务器，这个代理服务器可以访问到用户无法直接访问的目标网站；</p><p>于是用户可以先向代理服务器发出请求，告诉代理服务器需要访问的目标网站，代理服务器先取得用户需要的内容，再返回给用户，这就是正向代理。</p><p>在目标网站服务器的角度，只在代理服务器过来取得内容时有一次记录，有时候并不知道是用户的请求，也隐藏了用户的信息，这取决于代理服务器是否告诉目标网站服务器。</p><blockquote><p><strong>注</strong>：用户在使用正向代理时必须自行配置代理服务器的IP地址和端口。</p></blockquote><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110090242340.png"></p><span id="more"></span><h3 id="反向代理（Reverse-Proxy）"><a href="#反向代理（Reverse-Proxy）" class="headerlink" title="反向代理（Reverse Proxy）"></a>反向代理（Reverse Proxy）</h3><p>反向代理的概念和字面上的意思相同，与正向代理相反；</p><p>正向代理客户端需要通过代理服务器来寻找目标服务器进行资源访问；</p><p>反向代理则是目标服务器对客户端隐藏了自己的地址，通过暴露代理服务器让客户端对其进行请求，再由代理服务器根据规则访问目标服务器获得资源返回给客户端；</p><p>正向与反向的明显区别即在于：被动方和主动方进行了互换，由客户端主动使用代理服务器寻找目标服务器，转为了目标服务器隐藏自己，使用代理服务器让客户端进行访问。</p><p>作用：</p><ol><li>内网安全；由于对外暴露的是代理服务器，可以通过配置WAF等设置来防止对内部服务器的攻击。</li><li>负载均衡；代理服务器可以通过配置轮询、权重以及HashIP等规则来使多个请求分发到不同的服务器上，优化各个服务器的负载量。</li></ol><blockquote><p><strong>注</strong>：反向代理的这个过程对客户端是透明不可见的，客户端不需要配置代理服务器，且只会认为自己访问了一个服务器。</p></blockquote><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110091540186.png"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在实际情况中，一个服务器在面对多个客户端请求的时候压力会较大，甚至可能宕机崩溃。</p><p>因此企业服务应用往往会采用服务器集群结合反向代理服务器的方式，让反向代理服务器接收客户端请求，并通过指定的规则如：轮询、权重以及HashIP，分别将多个请求分发到不同的服务器上接收处理并返回给客户端，以达到服务器集群中各个服务器的负载始终维持在一个均衡的水平，这种解决方案就被称为负载均衡。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>一般来说，静态资源是指JavaScript、CSS、Img等文件，动态资源则是通过PHP、Java等后端语言运行一系列的代码逻辑来获取的。</p><p>动静分离可通过location对请求url进行匹配，将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。通常将静态资源放到nginx或CDN中，动态资源转发到后端应用服务器中。</p><p>在使用前后端分离之后，可以很大程度的提升静态资源的访问速度，同时减轻后端应用服务器的处理压力。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>配置了环境变量后可以直接使用 <code>nginx</code> 命令来操作nginx。</p><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>启动：nginx</p><p>立即停止：nginx -s stop</p><p>平滑停止：nginx -s quit</p><p>重启：nginx -s reopen</p><p>重载配置文件：nginx -s reload</p><h4 id="参数-OPTIONS"><a href="#参数-OPTIONS" class="headerlink" title="参数 OPTIONS"></a>参数 OPTIONS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@hazykam ~]<span class="comment"># nginx -?</span></span><br><span class="line">nginx version: nginx/1.20.1</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-p prefix]</span><br><span class="line">             [-e filename] [-c filename] [-g directives]</span><br><span class="line"> </span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this <span class="built_in">help</span></span><br><span class="line">  -v            : show version and <span class="built_in">exit</span></span><br><span class="line">  -V            : show version and configure options <span class="keyword">then</span> <span class="built_in">exit</span></span><br><span class="line">  -t            : <span class="built_in">test</span> configuration and <span class="built_in">exit</span></span><br><span class="line">  -T            : <span class="built_in">test</span> configuration, dump it and <span class="built_in">exit</span></span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : <span class="built_in">set</span> prefix path (default: /www/server/nginx/)</span><br><span class="line">  -e filename   : <span class="built_in">set</span> error <span class="built_in">log</span> file (default: logs/error.log)</span><br><span class="line">  -c filename   : <span class="built_in">set</span> configuration file (default: conf/nginx.conf)</span><br><span class="line">  -g directives : <span class="built_in">set</span> global directives out of configuration file</span><br></pre></td></tr></table></figure><blockquote><p>Nginx启动失败时错误信息：still could not bind()；表示端口被占用</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Nginx中的反向代理和负载均衡主要由两个模块负责</p><p>upstream：上行流，该模块中可以配置要转发到的服务器地址、端口以及分发权重，如果不配置权重参数则默认使用轮询。</p><p>server：server中的location子模块可以配置proxy_pass参数来指定反向代理的服务器地址，也可以引用upstream池</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202110120214481.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h3&gt;&lt;p&gt;正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径，另外还可以使用缓存的特性减少网络使用率。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;用户需要访问某个目标网站（如Google），但因为防火墙的存在而无法直接访问，但用户可以访问到一个代理服务器，这个代理服务器可以访问到用户无法直接访问的目标网站；&lt;/p&gt;
&lt;p&gt;于是用户可以先向代理服务器发出请求，告诉代理服务器需要访问的目标网站，代理服务器先取得用户需要的内容，再返回给用户，这就是正向代理。&lt;/p&gt;
&lt;p&gt;在目标网站服务器的角度，只在代理服务器过来取得内容时有一次记录，有时候并不知道是用户的请求，也隐藏了用户的信息，这取决于代理服务器是否告诉目标网站服务器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：用户在使用正向代理时必须自行配置代理服务器的IP地址和端口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/graytang/img-repo/raw/master/img/202110090242340.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Nginx" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://hazykam.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring知识点</title>
    <link href="https://hazykam.github.io/2021/10/18/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://hazykam.github.io/2021/10/18/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-10-18T09:15:07.000Z</published>
    <updated>2021-10-20T05:07:16.188Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h4><p>Spring是一个轻量级的开源的J2EE框架。它是容器也是框架，可以存放JavaBean，也可以作为中间层，在整合其他框架组件起到一个连接的作用。</p><p>Spring是一个拥有IoC控制反转和AOP面向切面特性的容器框架</p><ul><li>从大小和开销而言Spring都是轻量级的</li><li>通过IoC达到松耦合的目的，不再使对象之间产生强耦合</li><li>提供面向切面编程的支持，允许通过分离应用的业务逻辑和系统级服务进行内聚性的开发</li><li>可容纳JavaBean对象，并可对其配置和生命周期进行管理，起到容器的作用</li><li>可以将简单的组件配置组合成复杂的应用，起到框架的作用</li></ul><span id="more"></span><h4 id="AOP简述"><a href="#AOP简述" class="headerlink" title="AOP简述"></a>AOP简述</h4><p>一个系统会由许多不同的组件所组成，每个组件负责一块特定的功能。除了实现自身的核心功能以外，这些组件害经常承担额外的职责。例如日志、事务管理和安全，这样的核心服务经常会融入到负责核心业务逻辑的组件中，这些服务通常被称为横切关注点，因为它们会跨越系统的多个组件。</p><p>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。</p><p>日志代码往往水平地散布在所有对象层次中，而日志却和它所散布到的对象的核心逻辑毫无关系。</p><p>在OOP设计中，这导致了大量代码的重复，不利于各个模块的重用。</p><p>AOP：将程序中的交叉业务逻辑（比如安全、日志以及事务等），封装成一个切面，定义一个目标对象（具体业务逻辑）的切入点将其注入进去。AOP可以对某个对象或某些对象的功能进行增强，比如在执行某个对象方法的前后额外做一些其他的事情。</p><h4 id="IoC和DI简述"><a href="#IoC和DI简述" class="headerlink" title="IoC和DI简述"></a>IoC和DI简述</h4><p>参考：<a href="https://blog.csdn.net/bestone0213/article/details/47424255">https://blog.csdn.net/bestone0213/article/details/47424255</a></p><h4 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h4><p>ApplicationContext是BeanFactory的子接口，它提供了更完整的功能；</p><ol><li>继承了MessageSource，因此支持国际化</li><li>统一的资源文件访问方式</li><li>提供在监听器中注册bean的事件</li><li>同时加载多个配置文件</li><li>载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li></ol><ul><li>BeanFactory采用延迟加载的方式来注入bean，只有当需要用到某个bean时（调用getBean()），才实例化加载bean。这样会使得我们无法发现一些Spring的配置问题，如果bean的某一个属性没有注入，BeanFactory加载后，会直到第一次调用getBean方法时才抛出异常。</li><li>ApplicationContext会在容器启动时一次性创建所有的bean，以解决上述的问题，有利检查依赖属性是否被注入。同时因为ApplicationContext的预载入机制，当需要使用某个bean时就无需等待创建。</li><li>相对于基本的BeanFactory，ApplicationContext的不足是会占用更多的内存空间，当应用程序配置的bean较多时，程序的启动会比较慢。</li><li>BeanFactory通常以显式编程的方式被实例化，ApplicationContext还能以在配置文件中声明的方式被实例化，如使用ContextLoader。</li><li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li></ul><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241434459.png"></p><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><ul><li>singleton：默认作用域，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期与IoC容器一致（但在第一次被注入时才会创建）。</li><li>prototype：每一次getBean都会提供一个新的实例。</li><li>request：每次http请求都会创建一个新的bean，该作用域仅适用于WebApplicationContext环境。</li><li>session：同一个http session中共享一个bean，不同session则反之，仅适用于WebApplicationContext环境。</li><li>application：在ServletContext的生命周期中会复用一个单例的bean对象。</li><li>websocket：在websocket的生命周期中会复用一个单例的bean对象。</li></ul><p>global-session：全局作用域，一般用于Portlet应用环境中。当应用部署在Portlet容器中运行时，容器中会包含很多portlet，如果想要声明让所有portlet共用全局的存储变量，那么全局变量需要放在global-session中。全局作用域与Servlet中的session作用域效果相同。</p><h4 id="Spring框架中，单例模式的Bean是否线程安全"><a href="#Spring框架中，单例模式的Bean是否线程安全" class="headerlink" title="Spring框架中，单例模式的Bean是否线程安全"></a>Spring框架中，单例模式的Bean是否线程安全</h4><p>Spring中的bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。</p><p>如果bean是有状态的，那就需要开发人员自己来保证线程安全，最简单的方法就是改变bean的作用域，将“singleton”改为“prototype”，这样每次getBean都会返回一个新的bean对象，以保证线程安全。</p><ul><li>有状态的bean即为存储了数据的bean</li><li>无状态即为不会保存数据</li></ul><p>Controller、Service和Dao层本身并不是线程安全的，如果只是调用里面的方法，且多线程调用一个实例的方法时，会在内存中复制变量保存到线程自己的工作内存中，这是安全的。</p><blockquote><p><strong>注：不要在bean中声明任何有状态的实例变量或类变量，如果必须这样做时，需要使用ThreadLocal将变量变为线程私有的。</strong></p><p><strong>如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等方式以保证线程同步。</strong></p></blockquote><h5 id="Spring如何保证事务获取同一个Connection"><a href="#Spring如何保证事务获取同一个Connection" class="headerlink" title="Spring如何保证事务获取同一个Connection"></a>Spring如何保证事务获取同一个Connection</h5><p>Dao层会操作数据库Connection，Connection是有状态的，比如说数据库事务。Spring的事务管理器使用ThreadLocal为不同线程维护了一套独立的Connection副本，保证线程之间不会互相影响。</p><h4 id="Spring中的设计模式"><a href="#Spring中的设计模式" class="headerlink" title="Spring中的设计模式"></a>Spring中的设计模式</h4><p>简单工厂：由一个工厂类根据传入的参数，动态决定应该要创建哪一个产品类</p><blockquote><p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但在传入参数前创建还是传入后创建要根据具体情况来定。</p></blockquote><p>工厂方法：</p><blockquote><p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring在调用getBean()获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是该bean的getObject()的返回值。</p></blockquote><p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><blockquote><p>spring对单例的实现：spring仅提供了全局的访问点BeanFactory，但并没有从构造器级别去控制单例，这是因为spring管理的是任意的Java对象。</p></blockquote><p>适配器模式：</p><blockquote><p>spring定义了一个适配接口，让每种Controller都有一种对应的适配器实现类，让适配器代替Controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就能实现对SpringMVC的扩展。</p></blockquote><p>装饰器模式：动态地给一个对象添加一些额外的功能。就增加功能来说，Decorator模式相比生成子类更加灵活。</p><blockquote><p>spring中用到的包装器模式在雷鸣上有两种表现：一种是类名中带Wrapper的，另一种是类名中带Decorator的。</p></blockquote><p>动态代理：</p><blockquote><p>切面在应用运行时被织入就是依靠的动态代理。一般情况下，在织入切面时，容器会为目标对象动态地创建一个代理对象，AOP就是以这种方式织入切面的。</p><p>织入：把切面应用到目标对象并创建新的代理对象的过程。</p></blockquote><p>观察者模式：</p><blockquote><p>spring的事件驱动模型使用的是观察者模式，spring中Observer模式常用的地方是Listener的实现。</p></blockquote><p>策略模式：</p><blockquote><p>spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，spring中大量使用了Resource接口来访问底层资源。</p></blockquote><h4 id="Spring事务的实现方式和原理以及隔离级别"><a href="#Spring事务的实现方式和原理以及隔离级别" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别"></a>Spring事务的实现方式和原理以及隔离级别</h4><p>Spring中有两种使用事务的方式，分别是编程式和声明式，**@Transactional**注解就是声明式事务。</p><p>事务的概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。</p><p>比如可以通过在某个方法上增加@Transactional注解开启事务，这个方法中所有的sql都会在一个事务中执行，统一失败或成功。</p><p>在一个方法上添加@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean。在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有抛出异常，那么代理逻辑就会提交事务，如果抛出了异常，则会回滚事务。</p><p>可以通过@Transactional注解中的rollbackFor属性，针对指定的异常进行事务回滚的配置，默认情况下会对RuntimeException和Error进行回滚。</p><p><strong>隔离级别</strong></p><p>Spring事务隔离级别就是数据库的隔离级别，同时Spring中会有一个默认级别，Spring的默认级别会根据不同数据库的默认级别而变化。</p><ul><li>read uncommitted（未提交读）</li><li>read committed（提交读、不可重复读）-Oracle默认级别</li><li>repeatable read（可重复读）-MySQL默认级别</li><li>serializable（可串行化、可序列化）</li></ul><p><strong>级别越往下越严格，效率越低</strong></p><blockquote><p>当数据库配置的隔离级别是Read Committed，而Spring配置的隔离级别是Repeatable Read时，以Spring的配置为准，如果Spring设置的隔离级别数据库不支持，则取决于数据库。</p></blockquote><h4 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h4><p>多个拥有事务的方法相互调用时，事务如何在这些方法之间传播可以通过**@Transactional的propagation属性<strong>配合</strong>Propagation枚举类**来决定。</p><p>Propagation枚举类中的成员：</p><table><thead><tr><th>传播类型</th><th>说明</th></tr></thead><tbody><tr><td>REQUIRED（Spring默认的事务传播类型）</td><td>如果不存在外层事务，就主动创建事务；否则就加入外层事务。</td></tr><tr><td>SUPPORTS</td><td>如果不存在外层事务，就不开启事务；否则加入外层事务。</td></tr><tr><td>MANDATORY</td><td>如果不存在外层事务，就抛出异常；否则加入外层事务。</td></tr><tr><td>REQUIRED_NEW</td><td>总是主动开启事务；如果存在外层事务，就将外层事务挂起。</td></tr><tr><td>NOT_SUPPORTED</td><td>总是不开启事务；如果存在外层事务，就将外层事务挂起。</td></tr><tr><td>NEVER</td><td>总是不开启事务；如果存在外层事务，则抛出异常。</td></tr><tr><td>NESTED</td><td>如果不存在外层事务，就主动创建事务；否则就创建嵌套的子事务。</td></tr></tbody></table><blockquote><p><strong>外层</strong>：指调用这个方法的方法。</p><p><strong>挂起</strong>：将外层事务挂起后，方法之间的事务互不影响，各自执行，一个方法的事务被回滚不会影响另一个方法的事务。</p><p><strong>嵌套事务</strong>：父事务回滚时，子事务也会一起回滚；子事务的方法如果抛出了异常，父事务方法可以选择将异常捕获，这样即时子事务回滚了，父事务也不会回滚。</p></blockquote><h4 id="Spring事务在什么情况下会失效"><a href="#Spring事务在什么情况下会失效" class="headerlink" title="Spring事务在什么情况下会失效"></a>Spring事务在什么情况下会失效</h4><ol><li><p>发生自调用；</p><blockquote><p>在类中使用this调用了本类的方法（this通常省略），Spring的事务在代码层面上是利用<strong>AOP</strong>实现的，而AOP又是由<strong>代理模式</strong>实现的。</p><p>this指针指向的是自身这个真正的对象，而非负责执行的代理对象，因此发生自调用时Spring的事务会失效。</p><p>解决方法是将this指针替换成@Autowired自动注入的代理对象。</p></blockquote></li><li><p>被注解标注的方法不是public的；</p><blockquote><p>@Transactional 的作用范围是方法之间的调用，而private和protected方法无法像public方法一样被外部直接调用，所以当方法是非public的时候事务就会失效；</p><p>如果非要用在非public方法上，可以开启AspectJ代理模式。</p></blockquote></li><li><p>数据库不支持事务；如MySQL的MyISAM引擎则不支持事务。</p></li><li><p>类没有被Spring管理；如果类没有被@Component之类的注解标注，让Spring进行管理，那即时在方法上使用了@Transactional注解，Spring也无法提供支持。</p></li><li><p>异常没有抛出；事务方法通常是要抛出异常的，如果没有将异常抛出而是使用了try…catch处理了异常，事务就不会回滚。</p></li></ol><h4 id="Bean的自动装配方式"><a href="#Bean的自动装配方式" class="headerlink" title="Bean的自动装配方式"></a>Bean的自动装配方式</h4><ol><li>byName</li></ol><blockquote><p>byName方式会根据bean id和对象名进行装配，如果容器中有一个bean的id与被注入对象的名称相同，就会调用对象所属类的setter方法将bean装配进去；找不到则注入null。</p></blockquote><ol start="2"><li>byType</li></ol><blockquote><p>byType则是根据bean的类型和对象类型进行装配，如果容器中仅有一个bean的类型与被注入对象的类型相同，那就直接注入；找不到则注入null。</p><p>如果该类型的bean在容器中不唯一，则需要以@Qualifier、@Primary等方式进行限定，否则会抛出异常。</p></blockquote><ol start="3"><li>constructor</li></ol><blockquote><p>和byType有一点类似，constructor装配会将与被注入对象的构造器参数列表中，与参数类型相同的bean装配到对象中，如果没有相同类型的bean则抛出异常。</p></blockquote><p>@Autowired默认以byType方式进行装配，当找到多个相同类型的bean时，优先选择被@Primary标注的bean；</p><p>如果这时没有被@Primary标注的bean，byType方式就会失效，以byName方式装配；</p><p>@Qualifier注解实际上就是通过byName方式指定一个bean实现的。</p><h4 id="Spring、Spring-MVC、Spring-Boot之间的区别"><a href="#Spring、Spring-MVC、Spring-Boot之间的区别" class="headerlink" title="Spring、Spring MVC、Spring Boot之间的区别"></a>Spring、Spring MVC、Spring Boot之间的区别</h4><p>Spring是一个IoC容器，用来管理Bean，使用了依赖注入的方式实现了控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题，方便将不同类不同方法中的共性部分抽取成切面，自动注入到方法中执行，比如日志、异常等。</p><p>SpringMVC是spring对web框架的一个解决方案，它提供了一个总的前端控制器DispatcherServlet用来接收请求，定义了一套路由策略（url到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现到前端。</p><p>Spring Boot是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发Spring + SpringMVC应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）如redis、mongodb、es等，可以开箱即用。</p><h4 id="Spring-MVC的工作流程"><a href="#Spring-MVC的工作流程" class="headerlink" title="Spring MVC的工作流程"></a>Spring MVC的工作流程</h4><p>1、当用户向服务器发送请求时，会被 DispatcherServlet 前端控制器拦截。</p><p>2、DispatherServlet 解析用户访问的 URL，并调用处理器映射 HandlerMapping。</p><p>3、HandlerMapping 映射到对应的后端处理器 Handler（注意这里只是找到了对应的 Controller 类，并没有执行其中的方法），Handler 对象以及 Handler 对象相关的拦截器对象会被封装到 HandlerExecutionChain 对象中返回给 DispatcherServlet。</p><p>4、DispatcherServlet 根据后端处理器 Handler 对象来调用适合的 HandlerAdapter 处理器适配器。</p><p>5、HandlerAdapter 调用 Handler 对象执行 Handler 中的方法，在 Handler 的方法中，可以做一些额外的工作，如消息转换（如 JSON、XML 和 Java 对象的互转）、数据转换（如 String 和 Integer、Double的互转）、数据格式化（如日期）、数据校验（后端校验），最终返回 ModelAndView 对象给  DispatcherServlet，该对象包含视图名称和数据模型。</p><p>6、DispatcherServlet 根据 ModelAndView 对象来调用适合的视图解析器 ViewResolver。</p><p>7、ViewResolver 解析 ModelAndView （即将模型数据填充至视图中）返回具体的 view 给 DispatcherServlet。</p><p>8、DispatcherServlet 对 view 进行渲染，返回具体的视图给客户端显示，如 JSP，JSON、XML、PDF等。</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241436722.jpeg"></p><h4 id="Spring-MVC的九大组件"><a href="#Spring-MVC的九大组件" class="headerlink" title="Spring MVC的九大组件"></a>Spring MVC的九大组件</h4><p><strong>(1) HandlerMapping</strong></p><ul><li>HandlerMapping是一个接口，内部只有一个方法，用来查找Handler的。<br>  在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，<br>  它的作用是根据request找到对应的Handler。</li></ul><p><strong>(2) HandlerAdapter</strong></p><ul><li>适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就可以，<br>  但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。<br>  如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情。<br>  任意形式的Handler通过使用适配器，可以“转换”成固定形式，然后交给Servlet来处理。<br>  每种Handler都要有对应的HandlerAdapter才能处理请求。</li></ul><p><strong>(3) HandlerExceptionResolver</strong></p><ul><li>SpringMVC中专门负责处理异常的类,根据异常设置ModelAndView。<br>  之后交给render方法进行渲染,HandlerExceptionResolver只能处理页面渲染之前的异常，<br>  页面渲染过程中的异常，它是不能处理的。</li></ul><p><strong>(4) ViewResolver</strong></p><ul><li>这个接口只有一个方法:View resolveViewName(String viewName, Locale locale)<br>  throws Exception; 用来将String类型的视图名(viewName)和Locale解析为View类型的视图。</li></ul><p><strong>(5) RequestToViewNameTranslator</strong></p><ul><li>从request中获取ViewName</li></ul><p><strong>(6) LocaleResolver</strong></p><ul><li>有两个参数：一是视图名(viewName)，另一个是Locale。视图名是处理器返回的，<br>  但是Locale没有，而LocaleResolver就是用于从request解析出Locale。</li></ul><p><strong>(7) ThemeResolver</strong></p><ul><li>解析主题</li></ul><p><strong>(8) MultipartResolver</strong></p><ul><li>用于处理上传请求<br>  将普通的request包装成MultipartHttpServletRequest，就可以调用getFile方法获取File</li></ul><p><strong>(9) FlashMapManager</strong></p><ul><li>管理FlashMap的，FlashMap是用在redirect中传递参数。 就像我们写接口传递的参数，可以封装到Map中</li></ul><h4 id="Spring-Boot自动配置原理及流程"><a href="#Spring-Boot自动配置原理及流程" class="headerlink" title="Spring Boot自动配置原理及流程"></a>Spring Boot自动配置原理及流程</h4><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241436680.jpg"></p><h4 id="Spring-Boot中的Stater"><a href="#Spring-Boot中的Stater" class="headerlink" title="Spring Boot中的Stater"></a>Spring Boot中的Stater</h4><p>使用Spring + SpringMVC时，如果需要引入Mybatis等框架，需要到xml中定义Mybatis需要的bean。</p><p>Starter是一个jar包，jar包中会有一个@Configuration配置类，框架会根据自己的需要将bean定义在配置类中，接着在jar包中的META-INF/spring.factories中写入该配置类，Spring Boot就会按照约定的spi机制来加载该配置类。</p><p>开发人员只需在应用中对相应的stater包进行依赖，并配置相应属性（使用默认配置时不需要配置），就可以直接使用其功能进行开发。</p><h4 id="Spring-Boot-嵌入式服务器"><a href="#Spring-Boot-嵌入式服务器" class="headerlink" title="Spring Boot - 嵌入式服务器"></a>Spring Boot - 嵌入式服务器</h4><p>Spring Boot中内置了tomcat、jetty等常用服务器的jar包，在运行main方法时会自动启动。</p><p>内置服务器的好处是不需要再去下载安装tomcat，应用程序也不需要压缩成war包再放入webapp目录下运行，只需要在安装了jre的机器上直接执行jar包就可以完成部署。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Spring简介&quot;&gt;&lt;a href=&quot;#Spring简介&quot; class=&quot;headerlink&quot; title=&quot;Spring简介&quot;&gt;&lt;/a&gt;Spring简介&lt;/h4&gt;&lt;p&gt;Spring是一个轻量级的开源的J2EE框架。它是容器也是框架，可以存放JavaBean，也可以作为中间层，在整合其他框架组件起到一个连接的作用。&lt;/p&gt;
&lt;p&gt;Spring是一个拥有IoC控制反转和AOP面向切面特性的容器框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从大小和开销而言Spring都是轻量级的&lt;/li&gt;
&lt;li&gt;通过IoC达到松耦合的目的，不再使对象之间产生强耦合&lt;/li&gt;
&lt;li&gt;提供面向切面编程的支持，允许通过分离应用的业务逻辑和系统级服务进行内聚性的开发&lt;/li&gt;
&lt;li&gt;可容纳JavaBean对象，并可对其配置和生命周期进行管理，起到容器的作用&lt;/li&gt;
&lt;li&gt;可以将简单的组件配置组合成复杂的应用，起到框架的作用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="https://hazykam.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>悲观/乐观锁简述</title>
    <link href="https://hazykam.github.io/2021/10/18/%E9%94%81%E7%AE%80%E8%BF%B0/"/>
    <id>https://hazykam.github.io/2021/10/18/%E9%94%81%E7%AE%80%E8%BF%B0/</id>
    <published>2021-10-18T09:14:17.000Z</published>
    <updated>2021-10-20T05:10:54.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>锁的四种状态：无锁、偏向锁、轻量级锁、重量级锁</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁在调用资源时，会悲观的认为所有访问该资源的线程都会对其进行修改，因此需要严格同步线程的调用，在操作数据时会直接把资源锁住，只让一个线程进行调用，直到操作完成后再释放锁，上锁期间其他线程无法修改资源；</p><p>互斥锁就是悲观锁的一种，Java中的synchronized就是互斥锁；</p><p>但在有些场景下，可能多个线程对某个资源的调用大部分都是读取操作，就没有必要每次调用时都对资源进行锁定；</p><p>而因为线程的切换是会产生操作系统用户态与内核态的切换的，所以有时同步代码块执行的耗时可能会远远小于线程切换的耗时，这就有点本末倒置了。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁在调用资源时非常乐观，认为访问该资源的线程都不会对其进行修改，因此乐观锁其实是一种不会锁定资源的思想。</p><span id="more"></span><h3 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare and Swap）"></a>CAS（Compare and Swap）</h3><p>CAS（Compare and Swap）比较并交换是乐观锁的实现，是一种非阻塞的同步机制；</p><p>当多个线程同时访问一个资源时，每个线程都会产生三个操作数：</p><ul><li>调用的资源的内存位置（V）</li><li>资源未修改前原本的值（A）</li><li>需要写入的新值（B）</li></ul><p>线程会比较得到的值是否和指定位置资源的值一致，如果一致则将资源的值修改为新的值，否则进入自旋重试，直到操作成功或达到自旋终止次数而放弃操作；</p><p>自旋的次数可以通过启动参数进行修改，默认的自旋次数是10，以防止发生死循环；</p><h4 id="CAS的原子性是如何实现的"><a href="#CAS的原子性是如何实现的" class="headerlink" title="CAS的原子性是如何实现的"></a>CAS的原子性是如何实现的</h4><p>CAS中包含比较和交换两个动作，但必须保证这两个动作的原子性，否则无法保证线程同步；</p><p>CAS的原子性由CPU来提供硬件级别的同步原语支持，而无需使用操作系统的同步原语mutex进行上锁；</p><p>不同平台架构的CPU的CAS指令也不一样，x86中的是<code>cmpxchg</code>，而在arm下的是<code>LL/SC</code>；</p><h4 id="Java中是如何实现CAS操作的"><a href="#Java中是如何实现CAS操作的" class="headerlink" title="Java中是如何实现CAS操作的"></a>Java中是如何实现CAS操作的</h4><p>Java提供了AtomicInteger、AtomicBoolean等基本数据类型的原子类来实现CAS操作；</p><p>这些原子类的CAS实现底层是调用了对应平台的本地方法，本地方法是C++编写的，在C++的本地方法中会调用汇编命令来实现CAS操作；</p><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>假设线程1和线程2按照以下顺序执行：</p><ol><li>线程1读取到内存中的资源值为A</li><li>线程2读取到内存中的资源值，并将其修改为B</li><li>线程2再次将资源值改为A</li><li>线程1对资源进行CAS操作</li></ol><p>在第4步中，由于资源的值依旧为A，因此CAS操作成功，实际上该资源的值已经被线程B修改过了，这就是ABA问题，在某些场景下ABA问题会带来隐患；</p><p>对ABA问题，比较有效的解决方案是引入版本号机制，资源的值每发生一次变化都对版本号进行更新，在CAS操作时会同时比较版本号和资源的值，只有当两者都没有发生变化时，CAS才能执行成功；</p><h4 id="优缺点和适用场景"><a href="#优缺点和适用场景" class="headerlink" title="优缺点和适用场景"></a>优缺点和适用场景</h4><p><strong>1.使用限制</strong></p><p>与悲观锁相比，乐观锁的适用场景受到了更多的限制，例如：CAS只能保证对单个变量操作时的原子性，当涉及到多个变量时，CAS就没有办法处理了，synchronized则可以对代码块进行加锁处理，而且乐观锁的实现方式更为复杂</p><p><strong>2.读写是否频繁</strong></p><p>在悲观锁和乐观锁都能使用的情况下，我们需要对资源的读写操作是否频繁来进行考虑：</p><ul><li>当读操作的频率比较高，写操作的频率比较低时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，致使其他线程无法同时访问，影响并发，并且上锁和释放锁都需要消耗额外的资源；</li><li>当写操作的频率比较高时，悲观锁更有优势，乐观锁在执行更新时如果失败，会不断的自旋重试，线程自旋时CPU相当于在空转，非常浪费CPU资源；</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;锁机制&quot;&gt;&lt;a href=&quot;#锁机制&quot; class=&quot;headerlink&quot; title=&quot;锁机制&quot;&gt;&lt;/a&gt;锁机制&lt;/h3&gt;&lt;p&gt;锁的四种状态：无锁、偏向锁、轻量级锁、重量级锁&lt;/p&gt;
&lt;h4 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁&quot;&gt;&lt;/a&gt;悲观锁&lt;/h4&gt;&lt;p&gt;悲观锁在调用资源时，会悲观的认为所有访问该资源的线程都会对其进行修改，因此需要严格同步线程的调用，在操作数据时会直接把资源锁住，只让一个线程进行调用，直到操作完成后再释放锁，上锁期间其他线程无法修改资源；&lt;/p&gt;
&lt;p&gt;互斥锁就是悲观锁的一种，Java中的synchronized就是互斥锁；&lt;/p&gt;
&lt;p&gt;但在有些场景下，可能多个线程对某个资源的调用大部分都是读取操作，就没有必要每次调用时都对资源进行锁定；&lt;/p&gt;
&lt;p&gt;而因为线程的切换是会产生操作系统用户态与内核态的切换的，所以有时同步代码块执行的耗时可能会远远小于线程切换的耗时，这就有点本末倒置了。&lt;/p&gt;
&lt;h4 id=&quot;乐观锁&quot;&gt;&lt;a href=&quot;#乐观锁&quot; class=&quot;headerlink&quot; title=&quot;乐观锁&quot;&gt;&lt;/a&gt;乐观锁&lt;/h4&gt;&lt;p&gt;乐观锁在调用资源时非常乐观，认为访问该资源的线程都不会对其进行修改，因此乐观锁其实是一种不会锁定资源的思想。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="锁" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%81/"/>
    
    
    <category term="锁" scheme="https://hazykam.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程知识点</title>
    <link href="https://hazykam.github.io/2021/10/18/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://hazykam.github.io/2021/10/18/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-10-18T09:12:37.000Z</published>
    <updated>2021-10-18T10:36:06.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol><li>线程通常有五种状态：创建、就绪、运行、阻塞、死亡。</li><li>阻塞的情况又分为三种：<ol><li>等待阻塞：运行的线程执行了wait犯法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入了等待阻塞后无法自动唤醒，必须依靠其他线程调用notify或notifyAll方法才能被唤醒，wait方法是object类的方法。</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</li><li>其他阻塞：运行的线程执行了sleep或join方法，或发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态，sleep时Thread类的方法。</li></ol></li></ol><span id="more"></span><h4 id="sleep、wait、join、yield"><a href="#sleep、wait、join、yield" class="headerlink" title="sleep、wait、join、yield"></a>sleep、wait、join、yield</h4><p><strong>锁池</strong></p><p>所有需要竞争同步锁的线程都会放在锁池当中。</p><p>比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，直到持有锁的线程释放了同步锁后，锁池中的线程才可以去竞争同步锁，当某个线程得到锁后会进入就绪队列等待CPU调度。</p><p><strong>等待池</strong></p><p>调用wait方法后，线程会被放入等待池中。</p><p>等待池的线程不会去竞争同步锁，只有在调用了notify或notifyAll方法后，等待池的线程才会开始竞争锁，notify时随机从等待池中选出一个线程放到锁池，而notifyAll则会将等待池中所有的线程都放入锁池中。</p><p><strong>sleep和wait的区别</strong></p><ol><li>sleep是Thread类的静态本地方法，wait是Object类的本地方法。</li><li>sleep方法不会释放锁，但是wait会将锁释放，并且将线程加入到等待池（等待队列）中。</li><li>sleep方法不依赖synchronized，但是wait需要。</li><li>sleep不需要被主动唤醒（当休眠结束后退出阻塞），但是wait需要（当没有指定时间时）。</li><li>sleep一般用于当前线程的休眠，或者轮询暂停操作，wait则多用于多线程之间的通信。</li><li>sleep会让出CPU且强制切换上下文，wait则不一定，wait后还是可能有机会重新竞争到锁继续执行。</li></ol><p><strong>yield</strong>执行后线程会立刻释放CPU进入就绪状态，但是依然保留了CPU的执行资格，所以有可能CPU下次进行线程调度还是会让这个线程获取到CPU继续执行。</p><p><strong>join</strong>可以让线程执行插队的操作，例如在线程B的代码块中调用了线程A的join方法，线程B就会进入到阻塞队列，直到线程A运行结束或中断线程。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全实际上指的是堆的内存安全，堆是进程和线程的共享内存，可以被进程中的所有线程访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当多个线程访问同一个对象时，如果不进行额外的同步控制或其他的协调操作，调用这个对象之后依然可以获得正确的结果，我们就可以说这个对象是线程安全的。</span><br></pre></td></tr></table></figure><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>为所有非守护线程（即用户线程）提供服务的线程；任何一个守护线程都会为整个JVM中所有的用户线程服务。</p><p>守护线程依赖整个进程而运行，如果所有线程都结束运行了，守护线程会直接中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于守护线程的终止是无法自身控制的，因此不可以把IO、File之类的访问固有资源和事务处理等逻辑分配给它。</span><br></pre></td></tr></table></figure><p>举例，<strong>GC垃圾回收线程</strong>：GC就是一个经典的守护线程，当程序中不再有任何运行的用户线程，程序就不会再产生垃圾，垃圾回收器也就没事干了，所以当GC是JVM上仅剩的线程时，GC会自动中断。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p><p>应用场景：</p><ol><li>为其他线程提供服务支持</li><li>在任何情况下，程序结束时，这个线程立刻关闭也不会出现错误的结果，就可以作为守护线程；如果该线程必须被正确的关闭，否则会出现错误的结果，那这个线程一定不能是守护线程，而是用户线程</li></ol><p>thread.setDaemon(true)必须在thread.start()之前设置，如果将正在运行的用户线程设为守护线程则会抛出异常。</p><p>在守护线程中产生的新线程也是守护线程。</p><h4 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h4><p>关键字：synchronized、CAS、volatile</p><ul><li>原子性</li></ul><p>原子性是指在执行某部分代码时，cpu不可以被中断切换调度，只有全部执行完成和完全不执行两个结果。</p><ul><li>可见性</li></ul><p>当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程都能立刻看到变量修改后的值。</p><ul><li>有序性</li></ul><p>JVM为了优化执行效率，会在运行时一定程度上进行指令的重排序，如果在多线程的环境下发生指令重排，可能会导致执行的结果错误，这种情况就需要禁止指令重排以保证执行的有序性。</p><h4 id="线程池特性"><a href="#线程池特性" class="headerlink" title="线程池特性"></a>线程池特性</h4><ol><li>降低资源消耗；提高线程利用率，降低创建和销毁线程的开支</li><li>提高响应速度；当有任务进入时，线程池中的线程可以直接执行，不需要创建线程</li><li>提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控</li></ol><h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><p><code>corePoolSize</code> 池中核心线程的数量；即正常情况下会创建的线程数，这些线程创建后不会销毁，而是常驻在线程池中。</p><p><code>maxinumPoolSize</code> 池中可容纳线程的最大数量；如果当前任务较多，核心线程正忙且任务队列已满时，此时就会创建新的线程，池中线程总数不会超过这个值。</p><p><code>keepAliveTime</code> 核心线程以外的线程空闲存活时间；除核心线程以外的线程，当空闲时间达到这个值时，线程将会被销毁，可以通过<code>setKeepAliveTime</code>方法来设置空闲时间。</p><p><code>workQueue</code> 存放待执行任务的队列；当核心线程正忙时，如果有新任务进入时则会放入该队列，直到队列已满但还有新任务在持续进入时，则会开始创建新的线程。</p><p><code>ThreadFactory</code> 创建线程执行任务的工厂；可以使用默认的创建工厂，产生的线程都在同一个组内，拥有相同的优先级，且都不为守护线程。也可以选择自定义线程工厂，一般会根据业务来制定自定义的线程工厂。</p><p><code>Handler</code> 任务拒绝策略；有两种情况，第一种是调用<code>shutdown</code>等方法关闭线程池后，这时即时线程池内部还有没执行完的任务正在执行，但由于线程池已经关闭，向线程池提交的任务就会被拒绝。第二种则是当池中线程达到最大线程数时，线程池已经没有能力继续处理新提交的任务时，就会拒绝任务。</p><h4 id="线程池中阻塞队列的作用"><a href="#线程池中阻塞队列的作用" class="headerlink" title="线程池中阻塞队列的作用"></a>线程池中阻塞队列的作用</h4><ol><li><p>一般的队列只能保证一个有限长度的缓冲区，如果超出了缓冲区长度，就无法保留新进入的任务，而阻塞队列会通过阻塞将继续入队的任务保留。</p></li><li><p>阻塞队列拥有自动阻塞和唤醒的功能，不需要额外管理，当池中的核心线程没有任务可执行时，线程池会利用阻塞队列的<code>take</code>方法将核心线程挂起，使其进入wait状态，这样既维持了核心线程的存活，也释放了CPU资源。</p></li></ol><h5 id="为什么先加入队列而不是先创建线程执行？"><a href="#为什么先加入队列而不是先创建线程执行？" class="headerlink" title="为什么先加入队列而不是先创建线程执行？"></a>为什么先加入队列而不是先创建线程执行？</h5><p>在创建新的线程时，需要获取全局锁，这个时候其他的线程就会被阻塞，影响了整体效率；</p><p>当任务数量没有超过任务队列的大小时，核心线程通常可以正常执行任务，如果使用先创建线程执行的策略，在执行任务的过程中可能会使临时线程频繁地被创建和销毁，引起效率的降低。</p><h4 id="线程池-线程复用原理"><a href="#线程池-线程复用原理" class="headerlink" title="线程池 - 线程复用原理"></a>线程池 - 线程复用原理</h4><p>线程池会将线程和任务解耦，使其不绑定在一起，摆脱了通过Thread创建线程时一个线程必须对应一个任务的限制。</p><p>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对Thread进行了封装，当任务被执行时不会通过 <code>Thread.start()</code> 来创建新线程，而是让池中的每个线程执行一个“循环任务”，在“循环任务”中不停检查是否有任务需要被执行，如果有则直接调用任务中的 <code>run()</code> 将其当成一个普通的方法执行。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;h4 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;线程通常有五种状态：创建、就绪、运行、阻塞、死亡。&lt;/li&gt;
&lt;li&gt;阻塞的情况又分为三种：&lt;ol&gt;
&lt;li&gt;等待阻塞：运行的线程执行了wait犯法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入了等待阻塞后无法自动唤醒，必须依靠其他线程调用notify或notifyAll方法才能被唤醒，wait方法是object类的方法。&lt;/li&gt;
&lt;li&gt;同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。&lt;/li&gt;
&lt;li&gt;其他阻塞：运行的线程执行了sleep或join方法，或发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态，sleep时Thread类的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="线程" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="线程" scheme="https://hazykam.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记</title>
    <link href="https://hazykam.github.io/2021/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <id>https://hazykam.github.io/2021/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</id>
    <published>2021-10-18T09:10:41.000Z</published>
    <updated>2021-10-18T11:46:34.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h3><ul><li><p>List：有序，按对象进入的顺序存储对象，元素可重复，允许存在多个Null元素，可以使用Iterator进行遍历，也可以使用get(int index)通过下标的方式随机访问；由于对List使用Iterator进行遍历比较高效，所以Java中使用for each对List进行遍历时，本质上也是Iterator遍历。</p></li><li><p>Set：无序且不可重复，最多允许一个Null元素，遍历时只能使用Iterator逐个遍历。</p></li></ul><hr><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map是一种key-value键值对映射的集合，Map接口没有继承Collection接口；</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap，又称<strong>散列表</strong>、<strong>哈希映射</strong>，它存储的内容是<strong>键值对（key-value）映射</strong>；</p><p>HashMap实现了<strong>Map接口</strong>，Map接口<strong>定义了key映射到value的规则</strong>；</p><p>HashMap继承了<strong>AbstractMap</strong>，Abstract<strong>提供接口的主要实现</strong>，以最大幅度减少了HashMap实现Map接口所需的工作；</p><p>HashMap<strong>根据key的hash值存储数据</strong>，具有<strong>很快的访问速度</strong>，最多<strong>允许一条记录的key为null</strong>，<strong>不支持线程同步</strong>；</p><p>HashMap是<strong>无序</strong>的，这里的无序指的是<strong>不保证插入顺序</strong>，但<strong>遍历时的顺序不会改变</strong>。</p><span id="more"></span><h5 id="HashMap的存储结构"><a href="#HashMap的存储结构" class="headerlink" title="HashMap的存储结构"></a>HashMap的存储结构</h5><p>JDK1.7中HashMap采用的数据结构为：<strong>数组+链表</strong>；</p><p>JDK1.8中对其进行了优化，改为了：<strong>数组+链表+红黑树</strong>，并将<strong>插入元素的方式从头插法改为尾插法</strong>。</p><p><strong>结构图</strong>：</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241412884.png"></p><p><strong>HashMap中的几个关键属性</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量，这个指的是table的长度，在实例化时不传入Map的capacity，默认则为：1左移4位=16</span></span><br><span class="line"><span class="comment">// HashMap的容量一定是2的次幂数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 负载因子的默认值，实例化时未指定负载因子的值时，则为0.75，也就是75%</span></span><br><span class="line"><span class="comment">// 用于计算threshold扩容阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当前HashMap中K-V的总数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 扩容阈值，当HashMap中的K-V元素大于这个阈值时则会触发resize()方法进行扩容，目的在于减少哈希碰撞，用空间换取时间</span></span><br><span class="line"><span class="comment">// 计算公式：capacity * loadFactor;  这里的capacity指当前的数组长度</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 树化阈值和最小树化容量，当链表长度达到8，并且数组长度达到64时，链表会转化为红黑树</span></span><br><span class="line"><span class="comment">// 最小树化容量表示的是：当数组长度小于该值时，优先进行扩容，而不是树化，至少为4 * TREEIFY_THRESHOLD，否则会在调整大小和树化之间发生冲突</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反树化阈值，当红黑树中的节点减少至6时，红黑树会转换回链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对HashMap对象的修改次数，每次对HashMap进行更新或修改HashMap的内部结构都会+1</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h5 id="hash的概念"><a href="#hash的概念" class="headerlink" title="hash的概念"></a>hash的概念</h5><p>hash，一般翻译为散列，也可以音译为哈希。hash算法会把任意长度的输入，转换成固定长度的输出，作为这段数据的特征。</p><h6 id="hash碰撞"><a href="#hash碰撞" class="headerlink" title="hash碰撞"></a>hash碰撞</h6><p>使用hash的前提是实现了<code>equals()</code>和<code>hashCode()</code>两个方法，hashCode()的作用就是保证对象返回一个唯一的hash值；但有时可能产生两个对象计算出来的hash值一样的情况，这种情况就被称为<code>哈希碰撞</code>，HashMap中为了尽量减少哈希碰撞而加入了<code>扰动函数</code>。</p><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><h6 id="table的初始化"><a href="#table的初始化" class="headerlink" title="table的初始化"></a>table的初始化</h6><p>**Node&lt;K, V&gt;**：HashMap内部有一个<code>Node</code>类，在注释中也称为<code>bin</code>，Node即为HashMap中基本的<code>K-V</code>键值对，它实现了Map中的<code>Entry</code>接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Node其中包含：<code>key</code>、<code>value</code>、<code>hash</code>、<code>next</code>这几个属性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">// key的哈希值/散列特征</span></span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next;    <span class="comment">// 指向链表的下一个节点</span></span><br></pre></td></tr></table></figure><p>这些Node都被存放在HashMap内部维护的一个Node数组<code>table</code>，这个数组也称为桶<code>bucket</code></p><p>由于<code>Node</code>也是引用类型，所以<code>table</code>中存放的是指向链表或红黑树的<code>引用地址</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意点</strong>：</p><p>在查看源码时，发现table并不会在HashMap构造时初始化，而是会在<code>resize()</code>中进行初始化；</p></blockquote><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241413081.png"></p><p>思考：</p><p>由table初始化中又引出了一个问题，为什么是在resize()中初始化？</p><blockquote><p>查看对resize()的引用，可以看到有一个<code>putVal()</code>调用了resize()，而这个putVal()又会被<code>put()</code>调用</p></blockquote><p>再回过来看看putVal()，我们可以发现在<code>table为空</code>时会调用resize()</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241414507.png"></p><p>再来看resize()，先看注释</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241414615.png"></p><p>从注释中我们可以得知，resize()会<code>初始化</code>或<code>成倍扩展</code>table的大小</p><p>查看源码，发现确实在table为空的情况下，resize()方法内部才会对table进行初始化</p><p><img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241414898.png"></p><p>由此得出：</p><ul><li><strong>一般情况下，HashMap在初始化时并不会对table进行初始化，而是使用了懒加载的机制，只有在第一次put值时才会实例化table</strong></li><li><strong>HashMap每次扩容一定是原大小的2倍，而2的次幂数乘以2就是比原大小值大的最近一个2的次幂数</strong></li></ul><h6 id="table数组的长度一定为2的次幂数"><a href="#table数组的长度一定为2的次幂数" class="headerlink" title="table数组的长度一定为2的次幂数"></a>table数组的长度一定为2的次幂数</h6><p>HashMap中会通过一个<code>tableSizeFor()</code>方法来保证数组的长度永远为2的次幂数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：这个方法的功能是在<strong>不考虑大于最大容量</strong>的情况下，<strong>返回比输入参数大的，并且离输入参数最近的一个2的整数幂</strong>，比如输入参数为10，返回结果为16。</p><h5 id="低位掩码和扰动函数"><a href="#低位掩码和扰动函数" class="headerlink" title="低位掩码和扰动函数"></a>低位掩码和扰动函数</h5><p>HashMap中，<code>key</code>的<code>hash</code>值表示的是在桶数组中的下标，但并不是直接使用<code>Object</code>中的<code>hashCode()</code>获取的；</p><p>hashCode()返回的是int型散列值，而int类型的值是带符号的<strong>32位二进制数</strong>，也就是**-21亿到+21亿<strong>，前后加起来大概</strong>40多亿的映射空间**；</p><p>虽然这么大的范围很难产生碰撞现象，但<strong>内存无法提供一个这么大的空间来存放长度为40亿的数组</strong>，HashMap默认的初始数组大小也才到16，所以<strong>这个散列值无法拿来直接使用</strong>；</p><p>用之前还需要对数组的长度进行<code>取模运算</code>，得到的余数才能用来访问数组下标；</p><h6 id="低位掩码"><a href="#低位掩码" class="headerlink" title="低位掩码"></a>低位掩码</h6><p>但取模的效率比较低，而HashMap中使用了<code>按位与</code>来替代取模，这里就解释了为什么table数组的长度为什么一定要为<strong>2的次幂数</strong></p><blockquote><p>当数组长度为<strong>2的整数幂</strong>时，<strong>对(table.length - 1)使用按位与运算可以获得和取模一样的结果</strong></p></blockquote><p>HashMap通过<code>hash &amp; (table.length - 1)</code>这条公式来计算元素在table数组中的存放位置，这条公式等价于<code>hash % table.length</code>；</p><p><strong>2的次幂数在计算机中的特性</strong>：转换为二进制之后一定是<strong>最高位为1</strong>，其它有效位全部为0；当2的次幂数**-1时<strong>，转换为二进制则</strong>一定是减少一个最高位<strong>，</strong>有效位全部变为1**；</p><blockquote><p>例如：</p><p>2的4次幂=16</p><p>16转换成二进制是10000</p><p>当16-1=15转换为二进制时，则为1111</p><p>减少了一个最高位，其它有效位全部变为1</p></blockquote><p>这样，当table数组的长度-1时，转换为二进制就相当于一个<code>“低位掩码”</code>，当与<code>hash</code>值将进行<code>按位与</code>运算时，<strong>高位会全部归零</strong>，只<strong>保留低位</strong>，再转化为十进制作为数组下标；</p><p>而为什么要这样设计，则是因为<strong>取模操作相对来说开销比较大</strong>，使用位运算可以提高效率。</p><p>但是这里又会有一个问题，即使hash值分布的非常松散，要是<strong>只取最后几位</strong>，也会产生<strong>很频繁的哈希碰撞</strong>，还会可能产生<strong>最后几个低位成规律性重复的现象</strong>，<code>扰动函数</code>就是为了尽量减少这个问题。</p><h6 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap中加入了<code>扰动函数</code>，将key的hashCode()返回的hash值<strong>无符号右移</strong>了16位，让<strong>高16位也参与运算</strong>，和<strong>原本的hash值</strong>进行异或，也就是对hash值的<code>高16位</code>和<code>低16位</code>进行<code>异或运算</code>，保留了<code>高位和低位特征</code>，从而<code>加大低位的随机性</code>，<strong>减小哈希碰撞的发生概率</strong>。</p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法会调用<code>putVal</code>方法，当第一次put值时，table还未初始化，则调用<code>resieze</code>对其进行初始化；</p><p>putVal具体解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onlyIfAbsent：这个参数的作用是决定要不要传入的key已存在的情况下，替换原有的value；true：不替换，false：替换；调用put方法时这个值为false</span></span><br><span class="line"><span class="comment">// evict：这个参数作用于LinkedHashMap</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab：引用当前HashMap的table</span></span><br><span class="line">    <span class="comment">// p：计算插入元素key的hash得到数组下标，table中这个下标位置的元素引用会赋给p</span></span><br><span class="line">    <span class="comment">// n：table的长度</span></span><br><span class="line">    <span class="comment">// i：通过计算插入元素key的hash得到数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 当第一次调用put，也就是table还未初始化时，调用resize方法对table进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果要插入的元素计算出来的下标，table中这个位置为空，则将元素封装成一个Node节点放入这个位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 否则，当这个位置存在元素时</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e：用于执行判断和遍历的一个临时元素</span></span><br><span class="line">        <span class="comment">// k：用于执行判断的一个临时key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果，当前桶位已存在的元素的hash和要插入的元素hash相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            <span class="comment">// 并且，已存在元素的key和要插入元素的key相等的情况下</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 将已存在元素的引用赋给e用以之后的判断</span></span><br><span class="line">            e = p;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果已存在元素和要插入元素的key不相等，并且这个桶位的链表已经树化时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 将要插入的元素放入这个桶位的红黑树中，并将返回的TreeNode引用赋给e</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 当已存在元素和要插入元素的key不相等，并且当前桶位的链表还未树化时</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历当前桶位链表</span></span><br><span class="line">            <span class="comment">// binCount如同字面意思用于计算链表节点的数量，前置递增是因为已经判断了链表头部节点的key和要插入元素的key不相等</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果已存在元素的next指针为空，即遍历到链表尾部时；注意这个next指针也会赋给e，这是为了遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将要插入的元素封装成Node并追加到链表的尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果追加元素后，链表的长度大于等于树化阈值时</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 调用树化方法，树化方法又会判断table长度是否大于等于树化所要求的最小容量，如果没有达到最小树化容量，则调用resize扩容table，达到了则进行树化操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果当前遍历到的节点key和要插入元素的key相等时</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将e赋给p是为了遍历链表，因为e指向p的next</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// e!=null只有两种情况，插入位置的头节点和要插入元素的key相等，或者链表中的某个节点与要插入元素的key相等</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 保存旧元素的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 当确定要替换旧元素，或旧元素的value等于空时，用新的value覆写</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 这个方法是一个回调函数接口，用于LinkedHashMap，由LinkedHashMap实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧元素的value</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入了新的元素后，HashMap修改次数+1，替换旧元素的value操作不会计入</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 插入新的元素后，用于计算HashMap中元素总数的size+1，如果这个值大于了扩容阈值，则调用resize进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 这个方法同样是由LinkedHashMap实现的一个回调函数接口</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 返回null则表示没有旧元素被替换，或之前存在的key关联的是null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程描述：</p><blockquote><p>①.判断<strong>table是否为空</strong>，为空执行**resize()**进行扩容；</p><p>②.根据传入的，经过扰动后key的hash值<strong>计算得到插入的数组索引</strong>i，如果<strong>table[i]==null</strong>，直接封装节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的<strong>首个元素的key和插入元素的key是否相同</strong>，如果<strong>相同直接覆盖value</strong>，否则转向④；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果<strong>是红黑树</strong>，则直接调用**<code>putTreeVal</code>**，也就是红黑树版的putVal来进行判断和插入，否则转向⑤；</p><p>⑤.遍历table[i]中的链表查找<strong>是否存在相同的key</strong>，如果<strong>不存在则封装节点插入</strong>，<strong>插入后判断链表长度是否大于等于8</strong>，条件成立则<strong>调用<code>treeifyBin</code>树化方法</strong>，方法<strong>内部再进行判断</strong>，如果内部判断已<strong>完全达到树化条件</strong>后就<strong>执行树化</strong>；遍历过程中若发现<strong>key已经存在</strong>则<strong>直接覆盖旧的value</strong>；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p></blockquote><p><strong>注意</strong>：JDK<strong>1.8</strong>中，插入元素采用<strong>尾插法</strong>，<strong>1.8以前使用的头插法在并发时可能导致链表形成环</strong>，造成<strong>读取时死循环</strong>；同时，<strong>1.8是在插入元素后判断阈值再扩容</strong>的，而<strong>以前是先扩容再插入</strong>。</p><h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>HashMap每次扩容都会<strong>建立一个新的table桶数组</strong>，<strong>长度和阈值都变为原来的2倍</strong>；</p><blockquote><p><strong>位移运算的特性</strong>：一个十进制数<strong>转换成二进制</strong>，每往<strong>左移动一位</strong>得到的结果都是<strong>原本的2倍</strong>，<strong>往右则相反</strong>。</p></blockquote><p><strong>遍历旧桶</strong>，如果某个<strong>桶位上只有一个Node</strong>，直接<strong>计算该Node在新桶的位置</strong>；</p><p>如果某个<strong>桶位上是一个链表</strong>，则里面的<strong>元素新位置只有两种情况</strong>：</p><ul><li><strong>原地不动</strong></li><li>在原来的位置<strong>移动oldCap个位置</strong>，也就是旧桶的长度</li></ul><p>HashMap中使用<code>(e.hash &amp; oldCap) == 0</code>来判断是在原来的位置还是新位置；</p><p>如果hash值和该长度做与运算，结果为0，就说明该hash值一定小于数组长度（例如hash值为1），那么该hash值再和新数组的长度取摸的话，还是hash值本身，所以该元素的在新数组的位置和在老数组的位置是相同的；</p><p>比如，原本的桶长度为16，有两个元素，一个hash为1，一个为17，这两个元素都会被放入索引下标为1的桶位，如果此时扩容了，那么hash为17的元素就会移动到1+16=17的新位置；</p><p>扩容时，如果是链表，会使用头尾指针来连接新链表；</p><p>新桶指针：hiHead、hiTail</p><p>旧桶指针：loHead、loTail</p><h6 id="负载因子loadFactor为什么默认为0-75？"><a href="#负载因子loadFactor为什么默认为0-75？" class="headerlink" title="负载因子loadFactor为什么默认为0.75？"></a>负载因子loadFactor为什么默认为0.75？</h6><p>HashMap中的负载因子默认值为0.75，并且不推荐修改，有以下几个原因：</p><blockquote><ul><li>loadFactor太小，map中的table就会频繁的扩容，而每次扩容的开销都很大</li><li>loadFactor太大，map中的table即使非常多了也不多扩容，哈希碰撞越来越多引起的问题就是散列排布不均匀，链表越来越长，查找效率就会不断退化</li><li>0.75是一个折中的，比较理想的值，既不会产生频繁扩容的问题，也不会引起过多的哈希碰撞</li></ul></blockquote><h4 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h4><p>Map的遍历方式可以分为4类，每种类型下也有不同的实现方式，因此共计7种</p><ol><li><p><strong>迭代器（Iterator）</strong></p><ol><li>迭代器遍历EntrySet方式</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241416504.png"></p><ol start="2"><li>迭代器遍历KeySet方式</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Integer key = iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; -&gt; &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果同上</p></li><li><p><strong>foreach</strong></p><ol><li>foreach遍历EntrySet方式</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果同上</p><ol start="2"><li>foreach遍历KeySet方式</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot; -&gt; &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果同上</p></li><li><p>使用<strong>Lambda表达式（JDK1.8+）</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot; -&gt; &quot;</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果同上</p><ol start="4"><li><p><strong>Streams API（JDK1.8+）</strong></p><ol><li>Streams API单线程遍历</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 输出结果同上</p><ol start="2"><li>Streams API多线程遍历</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; -&gt; &quot;</span> + entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 输出结果：<img src="https://gitee.com/graytang/img-repo/raw/master/img/202109241420256.png"></p></li></ol><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap是<strong>有序</strong>的，和HashMap一样<strong>都继承了AbstractMap</strong>，不同的是HashMap实现的是<strong>Map接口</strong>，而TreeMap实现的是**<code>NavigableMap</code>接口<strong>，NavigableMap是</strong><code>SortedMap</code><strong>的一种，</strong>实现了对Map中key的排序**；</p><p>TreeMap的数据结构是<strong>红黑树</strong>，红黑树中存放的是<strong>Entry</strong>节点；</p><p>Treemap可以向<strong>构造函数</strong>传入一个**<code>Comparator</code><strong>，实现</strong>自定义的比较方法**；</p><p>HashMap可以<strong>允许一个key为null</strong>，<strong>多个value为null</strong>；而TreeMap<strong>不允许key为null</strong>，但可以<strong>允许多个value为null</strong>；</p><p>HashMap的底层有一个table数组，在添加、查找、删除等方法上<strong>效率非常高</strong>；而TreeMap是红黑树，<strong>相对而言会比较慢</strong>；</p><p>HashMap因为维护了一个数组，所以<strong>会造成空间的浪费</strong>；而TreeMap只需要保存树中的节点，所以<strong>占用空间比较小</strong>；</p><p>TreeMap在添加和删除节点时会进行重排序，会对性能有所影响；</p><p>HashMap和TreeMap都不允许duplicate（重复）key，两者都不是线程安全的。</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>LinkedHashMap<strong>继承自HashMap</strong>，<strong>实现了HashMap中的回调函数接口</strong>；另外，LinkedHashMap在HashMap的基础上<strong>增加了一条双向链表</strong>，以<strong>保证K-V键值对的插入顺序</strong>。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap是<strong>线程安全</strong>的HashMap，实现了<code>ConcurrentMap</code>接口；</p><p>JDK<strong>1.7</strong>中采用<strong>分段锁</strong>的机制<strong>实现并发的更新操作</strong>，底层采用<strong>数组+链表</strong>的存储结构；</p><blockquote><p>其包含两个两个核心静态内部类<code>Segment（段）</code>和<code>HashEntry</code>；</p><p>Segment继承了<code>ReentrantLock</code>，充当了<strong>锁</strong>的角色，<strong>每个Segment段中维护一个HashEntry数组</strong>，相比<strong>Hashtable不管是put还是get都需要<code>synchronized</code><strong>，</strong>每个线程只会锁定一个Segment</strong>，锁的粒度变小了，对<strong>其他线程访问的Segment没有影响</strong>；</p><p>HashEntry用来<strong>封装散列表的K-V键值对</strong>，<strong>和HashMap的Node不同</strong>的是，HashEntry对<strong>value使用了<code>volatile</code>修饰</strong>，保证了<strong>获取value时的线程可见性</strong>；</p><p><strong>每个桶是由若干个HashEntry对象链接起来的链表</strong>；</p></blockquote><p>JDK<strong>1.8</strong>中使用了<code>synchronized</code>和<code>CAS(Compare and Swap)</code>实现同步，虽然内部仍然保留了Segment，但仅仅是为了保证序列化时的兼容性，并且数据结构采用了<strong>数组+链表+红黑树</strong>；</p><p>ConcurrentHashMap中的<strong>负载因子</strong>被<strong>final</strong>修饰，<strong>不可修改</strong>；在<strong>构造函数</strong>中传入的loadFactor只会影响<strong>初始的表密度</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><strong>List</strong>：一种<strong>有序的、可重复</strong>的集合，可以根据下标访问元素，实现类有<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>；</p><p><strong>Set</strong>：和List相反，<strong>无序、且不可重复</strong>，只能根据元素本身进行访问，实现类有<code>HashSet</code>、<code>TreeSet</code>，<strong>HashSet被LinkedHashSet所继承</strong>；</p><p><strong>Queue</strong>：一种<strong>FIFO(first in first out)<strong>的集合，只允许在</strong>队头出列</strong>、<strong>队尾入列</strong>；</p><p><strong>Deque</strong>：<strong>双端队列</strong>，继承了Queue接口，可以<strong>在队列两端进行操作</strong>；</p><p>集合和数组的区别：</p><p>数组</p><ul><li>长度<strong>固定</strong></li><li>只能<strong>存储同一种类型的元素</strong></li><li>可以存储<strong>基本数据类型</strong>和<strong>引用类型</strong></li></ul><p>集合</p><ul><li>长度<strong>可变</strong></li><li>可以<strong>存储不同类型的元素</strong>（通常情况下不这么做）</li><li>只能存储<strong>引用类型</strong>（即使存储的是int，也会自动装箱成Integer）</li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList继承自<code>AbstractList</code>，实现了<code>List</code>接口，本质上是一个<strong>默认初始长度为10</strong>，允许<strong>存储null值</strong>，且<strong>支持自动扩容</strong>的<strong>数组</strong>，ArrayList<strong>非线程安全</strong>；</p><p>ArrayList<strong>基于数组</strong>作为底层数据结构，支持<strong>随机访问</strong>，具有<strong>查询修改效率高</strong>、<strong>插入删除效率低</strong>的特点；</p><p>ArrayList每次扩容会创建一个新的数组，容量会变为<strong>原来的1.5倍左右</strong>（oldCapacity为偶数时1.5倍，为奇数时1.5倍左右），再将原数组中的元素复制到新数组中；</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList继承自<code>AbstractSequentialList</code>，实现了<code>List</code>和<code>Deque</code>接口，和数组一样是一种<strong>线性数据结构</strong>，但不像数组一样在物理存储和逻辑上都为线性，链表<strong>只是在逻辑上呈线性</strong>，链表中的每个节点包含<strong>存储的数据和指向下一个节点的指针</strong>；</p><p>链表也分为单向链表和双向链表，JDK1.6时LinkedList为双向循环链表，1.7是<strong>双向链表</strong>，取消了循环以便区分头尾；</p><p>和ArrayList相比，<strong>插入删除效率高</strong>、<strong>查询修改效率低</strong>，但<strong>无需扩容</strong>，LinkedList<strong>非线程安全</strong>；</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>和ArrayList类似，底层数据结构也是数组，支持线程同步，效率低，每次扩容为原大小的2倍，Stack是Vector的子类；</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet底层实际上就是一个TreeMap，在TreeSet中存入数据相当于存入TreeMap的key部分；TreeSet中的元素是不可重复的，且不会记录元素的存放顺序，但它可以按照元素大小顺序自动排序；</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet底层是HashMap，和TreeSet与TreeMap的关系一样；HashSet无序、不可重复且查询效率高；</p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>在HashSet的基础上维护了一个链表，用来记录元素的存放顺序，保证元素有序且不可重复；</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;List和Set的区别&quot;&gt;&lt;a href=&quot;#List和Set的区别&quot; class=&quot;headerlink&quot; title=&quot;List和Set的区别&quot;&gt;&lt;/a&gt;List和Set的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;List：有序，按对象进入的顺序存储对象，元素可重复，允许存在多个Null元素，可以使用Iterator进行遍历，也可以使用get(int index)通过下标的方式随机访问；由于对List使用Iterator进行遍历比较高效，所以Java中使用for each对List进行遍历时，本质上也是Iterator遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set：无序且不可重复，最多允许一个Null元素，遍历时只能使用Iterator逐个遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h3&gt;&lt;p&gt;Map是一种key-value键值对映射的集合，Map接口没有继承Collection接口；&lt;/p&gt;
&lt;h4 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h4&gt;&lt;p&gt;HashMap，又称&lt;strong&gt;散列表&lt;/strong&gt;、&lt;strong&gt;哈希映射&lt;/strong&gt;，它存储的内容是&lt;strong&gt;键值对（key-value）映射&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;HashMap实现了&lt;strong&gt;Map接口&lt;/strong&gt;，Map接口&lt;strong&gt;定义了key映射到value的规则&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;HashMap继承了&lt;strong&gt;AbstractMap&lt;/strong&gt;，Abstract&lt;strong&gt;提供接口的主要实现&lt;/strong&gt;，以最大幅度减少了HashMap实现Map接口所需的工作；&lt;/p&gt;
&lt;p&gt;HashMap&lt;strong&gt;根据key的hash值存储数据&lt;/strong&gt;，具有&lt;strong&gt;很快的访问速度&lt;/strong&gt;，最多&lt;strong&gt;允许一条记录的key为null&lt;/strong&gt;，&lt;strong&gt;不支持线程同步&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;HashMap是&lt;strong&gt;无序&lt;/strong&gt;的，这里的无序指的是&lt;strong&gt;不保证插入顺序&lt;/strong&gt;，但&lt;strong&gt;遍历时的顺序不会改变&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://hazykam.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="HashMap" scheme="https://hazykam.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java知识点</title>
    <link href="https://hazykam.github.io/2021/10/18/Java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://hazykam.github.io/2021/10/18/Java%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-10-18T09:08:17.000Z</published>
    <updated>2021-10-18T10:31:25.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>什么是面向对象</p><p>对比面向过程，是两种不同的处理问题时的角度</p><p>面向过程更注重实现的每一个步骤及顺序，面向对象更注重实现过程中有哪些参与者（对象）、以及每个对象需要做什么</p><span id="more"></span><p>比如：人用洗衣机洗衣服</p><p>面向过程会将任务拆解成一系列的步骤（函数）：打开洗衣机 -&gt; 放入衣物 -&gt; 倒洗衣液 -&gt; 清洗 -&gt; 烘干</p><p>面向对象会拆出人和洗衣机两个对象：</p><p>人做的事：打开洗衣机、放入衣物、倒洗衣液</p><p>洗衣机做的事：清洗、烘干</p><p>面向过程更加直接高效，而面向对象更易于复用、扩展和维护</p><h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><p><strong>封装</strong>：封装的意义在于明确标识出允许外部使用的成员函数和属性，内部细节对外部调用者透明，调用者无需关心内部实现</p><p><strong>继承</strong>：继承基类的方法，并作出自己的改变和扩展，父子类中共性的方法或属性可以直接调用父类中的，而不需要再额外定义，只需在子类扩展一些额外的功能</p><p><strong>多态</strong>：多态基于继承特性，基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同</p><p>继承父类 -&gt; 重写父类方法 -&gt; 父类引用指向子类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure><p>使用多态特性时，无法调用子类特有的方法</p><hr><p>stack：栈</p><p>heap：堆</p><h3 id="JDK、JRE和JVM的关系"><a href="#JDK、JRE和JVM的关系" class="headerlink" title="JDK、JRE和JVM的关系"></a>JDK、JRE和JVM的关系</h3><p>JDK（Java开发工具包）中包含了JRE（Java运行环境），JRE中包含了JVM（Java虚拟机）。</p><p>.java文件通过JDK中的javac编译后生成.class文件，class文件可以在不同平台的JVM上来调用JRE的lib类库来进行解释运行。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final修饰类，表示类不可变，不可继承，比如String具有不可变性</p><p>final修饰方法，表示该方法不可重写，比如模板方法，可以固定我们的算法</p><p>final修饰变量，这个变量就会变为常量</p><p><strong>注意：</strong></p><ul><li><p>修饰的是基本数据类型，这个值本身不能修改；</p></li><li><p><span id="final-ref">==<strong>修饰的是引用类型，引用的指向不能够改变，但是引用类型中的属性可以改变</strong>==</span></p></li></ul><p>引用类型会在栈中拥有一个引用，这个引用指向了堆中的一块内存，也就是对象的信息</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Student student = <span class="keyword">new</span> Student(<span class="number">18</span>, <span class="string">&quot;Joker&quot;</span>);</span><br><span class="line">student.setName(<span class="string">&quot;Panther&quot;</span>);    <span class="comment">// 注意，这种是可以的</span></span><br></pre></td></tr></table></figure><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>抽象类中可以存在普通成员函数，接口中只能存在public abstract方法，这是默认强制的。</li><li>抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型的，这是默认强制的。</li><li>抽象类只能被继承一个，接口可以被实现多个。</li></ul><p>接口的设计目的，是对类的行为进行约束，接口要求实现类必须实现接口中所定义的抽象方法，是一种强制要求不同的类具有相同行为的机制，它约束了行为的有无，但不对具体实现进行限制。</p><p>抽象类的设计目的，是代码复用，当不同的类具有相同的行为，且部分行为的实现方式一致时，可以让这些类都继承一个抽象类，实现代码复用。而存在差异化的行为也就是抽象的方法，留给各个子类自己实现，抽象类因为存在抽象方法，所以不允许被实例化。</p><p>抽象类是对类的本质进行抽象，表达的是<code>is a</code>的关系，比如：<code>Benz is a Car</code>（奔驰是一部车），抽象类包含并实现了子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</p><p>接口是对行为的抽象，表达的是<code>like a</code>的关系，比如：<code>Bird like a Aircraft</code>（鸟像飞行器一样可以飞），实现类的本质没有变，但接口约束了一个类会有哪些行为，至于实现类主题是谁、如何实现，接口并不关心。</p><hr><h3 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h3><p>==在比较基本数据类型时，比较的是值；在比较引用类型时，比较的是引用指向的值，也就是地址；</p><p>equals只有引用类型可以调用，默认比较的也是地址，因为这个方法定义在Object上，默认的实现就是比较地址；</p><p>自定义的类，如果需要比较的是值而非地址，需要像String一样重写equals方法；</p><p>equals本质上就是==，只不过引用类型可以对其进行重写，将其变为值比较。</p><hr><h3 id="equals和hashCode的关系"><a href="#equals和hashCode的关系" class="headerlink" title="equals和hashCode的关系"></a>equals和hashCode的关系</h3><p>hashCode顾名思义是一个“<strong>散列值码</strong>”，散列值<strong>不具有唯一性</strong>，但<strong>具有离散性</strong>，其意义在于<strong>HashMap</strong>之类的集合<strong>可以通过hashCode快速比较对象</strong>，从而<strong>增加查询效率</strong>；</p><p>两个对象在使用equals方法进行比较时，hashCode必须相等，但<strong>hashCode相等并不代表两个对象一定相等</strong>；</p><p>如果没有重写hashCode方法，则使用Object默认的hashCode，<strong>默认的hashCode无法保证相同的两个对象hashCode也相等</strong>；</p><p><strong>一般情况下都建议重写hashCode方法</strong>，原因如下：</p><ul><li>如果想把对象放入Set中或者作为Map的key时，重写hashCode可以保证equals判断的准确性，确保元素或key的唯一。</li><li>在集合中比较两个对象是否相等时，如果两个对象的hashCode不相等，一般情况下就可以直接认为这两个对象不相等，如果hashCode相等，才会调用重写的equals方法进行值比较从而判断是否相等，可以提高比较的效率。</li></ul><p><strong>必须重写hashCode的情况</strong>：</p><p>如果想把对象存入例如HashSet、HashMap之类的以hashCode为核心的数据结构中，必须确保唯一性和查询效率，在重写equals的同时也必须重写hashCode，若不重写hashCode可能导致HashSet、HashMap不能正常的运作。</p><hr><h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><p>Effective Java中第15条<code>使可变性最小化</code>中对<code>不可变类</code>的解释：</p><p>不可变类是指实例不能被修改的类。每个实例中包含的所有信息都必须在创建实例时提供，并且在对象的整个生命周期内固定不变。</p><p>为了使类不可变，要遵循下面五条规则：</p><blockquote><ol><li><strong>不要提供任何会修改对象状态的方法。</strong></li><li><strong>保证类不会被扩展。</strong>一般的做法时让这个类被final所修饰，防止被子类继承，破坏该类的不可变行为。</li><li><strong>使所有的field都是final的。</strong></li><li><strong>使所有的field都为private。</strong>防止外界获得访问被field引用的可变对象的权限，并防止外界直接修改这些对象。</li><li><strong>确保对于任何可变性组件的互斥访问。</strong>如果类具有指向可变对象的field，则必须确保该类无法被外界获得指向这些对象的引用。</li></ol></blockquote><p>在Java类库中包含许多不可变类，例如：String、基本类型的包装类、BigInteger、BigDecimal等等。</p><p>综上所述，不可变类具有一些具有一些显著的通用特征：</p><ul><li>类本身是final修饰的</li><li>所有的field几乎都是private且final的</li><li>不会对外暴露可以修改实例属性的方法</li></ul><hr><h3 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h3><p>String是引用类型，String类型是不可变的，给一个已经有值的String对象进行二次赋值时，不会再原本的内存地址上修改数据，而是<strong>在堆中重新生成一个对象，将栈中的引用指向更改为新对象的地址</strong>。</p><h4 id="String源码实现"><a href="#String源码实现" class="headerlink" title="String源码实现"></a>String源码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">     * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../platform/serialization/spec/output.html&quot;&gt;</span></span><br><span class="line"><span class="comment">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码，String类本身是被final修饰的，满足了不可变类中，保证类不会被扩展的原则。</p><p>分析String中的几个field，其中最主要的是<code>value</code>，存储了String实例的值，由于使用了private final修饰，正常情况下外界无法修改value的值。</p><p>但仅凭private和final是无法保证String的不可变的：<a href="#final-ref">final的特性</a>；</p><p>如果类本身提供修改实例的方法，那也就没有办法保证不变性了，而不可变类的第一条原则就是<strong>不要提供任何会修改对象状态的方法</strong>；</p><p>而String类提供的对字符串进行操作的函数，例如：substring、concat、replace等，其中的<strong>每个实现都不会对原有的String实例中的value产生任何影响</strong>，进一步保证了String的不可变。</p><h4 id="String常量池"><a href="#String常量池" class="headerlink" title="String常量池"></a>String常量池</h4><p>JVM为了提高字符串的<code>复用性</code>，减少字符串对象的重复创建，特别维护了一个字符串的<code>字面量常量池</code>。</p><p>常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，运行期间也有可能将新的常量放入池中。在 Java 虚拟机规范中把方法区描述为堆的一个逻辑部分，但它却有一个别名叫 <code>Non-Heap</code>，目的应该是为了和 Java 堆区进行区分。</p><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// output =&gt; false</span></span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// output =&gt; true</span></span><br></pre></td></tr></table></figure><p>例1中的输出为<code>false</code>，<code>==</code>在比较基本数据类型时比较的是值，而在比较引用类型时比较的是引用指向的内存地址；使用<code>new</code>关键字时，会直接在堆中生成一个新的String对象，不会去查找常量池中是否存在这个值，所以本质上例1中的<code>str1</code>和<code>str2</code>指向的内存地址是不一样的。</p><p>例2之所以为<code>true</code>，是因为例2中的写法会先在字面量常量池中查找是否存在值<code>123</code>，若存在直接返回这个值的引用，若不存在则创建一个值为<code>123</code>的String对象并存入字面量常量池中；而由于String的不可变和字面量常量池的特性，在对<code>str2</code>进行二次修改时，如果常量池中不存在修改的目标值，则会新建一个对象，不会对<code>str1</code>造成影响，保证了数据之间的安全。</p><p>使用<code>new</code>生成的String对象也可以放入字面量常量池，String类提供了一个native方法<code>intern()</code>用来将对象的值放入常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">str2=str2.intern();</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// output =&gt; true</span></span><br></pre></td></tr></table></figure><p>上面的输出为 <code>true</code>。<code>str2</code> 调用 <code>intern()</code> 函数后，首先在字符串常量池中寻找是否存在值为 <code>123</code> 的对象，若存在直接返回该对象的引用，若不存在，加入 <code>str2</code> 并返回。上述代码中，常量池中已经存在值为 <code>123</code> 的 <code>str1</code> 对象，则直接返回 <code>str1</code> 的引用地址，使得 <code>str1</code> 和 <code>str2</code> 指向同一个内存地址。</p><h4 id="不可变类的好处"><a href="#不可变类的好处" class="headerlink" title="不可变类的好处"></a>不可变类的好处</h4><p>Effective Java中总结了不可变类的特点：</p><ul><li><strong>不可变类比较简单。</strong></li><li><strong>不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地共享。</strong></li><li><strong>不仅可以共享不可变对象，甚至可以共享它们的内部信息。</strong></li><li><strong>不可变对象为其他对象提供了大量的构建。</strong></li><li><strong>不可变类唯一的缺点是：对于每个不同的值都需要一个单独的对象。</strong></li></ul><p>而String不可变最重要的原因，就是<strong>安全</strong>。</p><p>来看一个HashSet用StringBuilder做元素的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HashSet&lt;StringBuilder&gt; hs=<span class="keyword">new</span> HashSet&lt;StringBuilder&gt;();</span><br><span class="line">        StringBuilder sb1=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        StringBuilder sb2=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;aaabbb&quot;</span>);</span><br><span class="line">        hs.add(sb1);</span><br><span class="line">        hs.add(sb2);    <span class="comment">//这时候HashSet里是&#123;&quot;aaa&quot;,&quot;aaabbb&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">        StringBuilder sb3=sb1;</span><br><span class="line">        sb3.append(<span class="string">&quot;bbb&quot;</span>);  <span class="comment">//这时候HashSet里是&#123;&quot;aaabbb&quot;,&quot;aaabbb&quot;&#125;</span></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//[aaabbb, aaabbb]</span></span><br></pre></td></tr></table></figure><p>StringBuilder型变量sb1和sb2分别指向了堆内的字面量”aaa”和”aaabbb”。</p><p>把他们都插入一个HashSet，到这一步没问题。但如果后面把变量sb3也指向sb1的地址，再改变sb3的值，因为StringBuilder没有不可变性的保护，sb3直接在原先”aaa”的地址上进行修改，导致sb1的值也变了。这时候，HashSet上就出现了两个相等的键值”aaabbb”。<strong>破坏了HashSet键值的唯一性</strong>。所以<strong>千万不要用可变类型做HashMap和HashSet键值。</strong></p><p>还有一个就是在并发场景下，多个线程同时读一个资源，是不会引发竟态条件的。只有对资源做写操作才有危险。<strong>不可变对象不能被写，所以线程安全</strong>。</p><h4 id="String是否真的不可变"><a href="#String是否真的不可变" class="headerlink" title="String是否真的不可变"></a>String是否真的不可变</h4><p>String的确是个不可变类，但反射可以做到很多通常情况下做不到的事情，来看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">Field field = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);    <span class="comment">// 通过反射直接获取value数组</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);    <span class="comment">// 将value设为可访问状态</span></span><br><span class="line"><span class="comment">// get：返回指定对象上此Field表示的字段的值。 如果值具有原始类型，则该值将自动包装在一个对象中。</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) field.get(str);    <span class="comment">// 获取str对象中的value</span></span><br><span class="line">value[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;    <span class="comment">// 修改value数组</span></span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">//  ↓</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 133</span></span><br></pre></td></tr></table></figure><p>通过以上代码，即可通过反射破坏String的不可变性。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>除了 String 类，系统类库中还提供了一些其他的不可变类，基本类型的包装类、BigInteger、BigDecimal等等。这些不可变类比可变类更加易于设计、实现和使用，不容易出错且更加安全。另外，要记住并不仅仅是靠一个 <code>final</code> 关键字来实现不可变的，更多的是靠类内部的具体实现细节。</p><hr><h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><p>String跟另外两个类的区别是：</p><blockquote><p> String是final类型，每次声明的都是不可变的对象；由于不可变的特性，String是线程安全的，每次更改都会产生并返回新的String对象。</p></blockquote><p>StringBuffer、StringBuilder都是可变的，两者都可以在原有的对象上进行操作，所以如果需要经常改变字符串的内容，则建议采用这两个类。</p><p>StringBuffer和StringBuilder：</p><p>StringBuffer是线程安全的，StringBuilder则是线程不安全的，而线程不安全带来的好处就是效率更高。</p><h4 id="什么时候考虑线程安全"><a href="#什么时候考虑线程安全" class="headerlink" title="什么时候考虑线程安全"></a>什么时候考虑线程安全</h4><p>思考：</p><p>什么情况下，我们才会考虑线程安全的问题？</p><blockquote><p>当多个线程同时访问同一个资源时，我们才会考虑线程安全的问题。</p></blockquote><p>开发中，我们通常用StringBuilder来解决什么问题？</p><blockquote><p>通常我们使用StringBuilder来处理字符串拼接和修改等问题。</p></blockquote><p>我们一般在哪里使用StringBuilder？</p><blockquote><p>我们一般只会在方法内创建StringBuilder来使用。</p></blockquote><p>基于上述思考，再来设想一个实际场景：</p><p>在一个并发场景下，多个线程来调用service层中的某一个方法，例如<code>add()</code>，我们在这个方法中<code>new</code>了一个StringBuilder；每个线程调用这个方法时，都会在栈中生成一个单独的栈帧，因此每个线程都会独享一个StringBuilder，这种情况下并不会造成多个线程同时访问一个StringBuilder，因此不会产生边界问题，这种情况下，我们可以放心的使用StringBuilder。</p><p>在实际开发中，我们会优先采用StringBuilder：</p><blockquote><p>StringBuilder &gt; StringBuffer &gt; String</p><ul><li>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h3&gt;&lt;p&gt;什么是面向对象&lt;/p&gt;
&lt;p&gt;对比面向过程，是两种不同的处理问题时的角度&lt;/p&gt;
&lt;p&gt;面向过程更注重实现的每一个步骤及顺序，面向对象更注重实现过程中有哪些参与者（对象）、以及每个对象需要做什么&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://hazykam.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="Java" scheme="https://hazykam.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
